// Package service provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package service

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAccountByAddress request
	GetAccountByAddress(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAddresses request
	GetAllAddresses(ctx context.Context, params *GetAllAddressesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllIlks request
	GetAllIlks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIlkByName request
	GetIlkByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserBorrows request
	GetUserBorrows(ctx context.Context, params *GetUserBorrowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserDeposits request
	GetUserDeposits(ctx context.Context, params *GetUserDepositsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchReserveDataByAsset request
	FetchReserveDataByAsset(ctx context.Context, params *FetchReserveDataByAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLendingPoolBorrowWithBody request with any body
	CreateLendingPoolBorrowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLendingPoolBorrow(ctx context.Context, body CreateLendingPoolBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLendingPoolDepositWithBody request with any body
	CreateLendingPoolDepositWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLendingPoolDeposit(ctx context.Context, body CreateLendingPoolDepositJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLendingPoolRepayWithBody request with any body
	CreateLendingPoolRepayWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLendingPoolRepay(ctx context.Context, body CreateLendingPoolRepayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetLendingPoolAssetCollateralWithBody request with any body
	SetLendingPoolAssetCollateralWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetLendingPoolAssetCollateral(ctx context.Context, body SetLendingPoolAssetCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLendingPoolWithdrawWithBody request with any body
	CreateLendingPoolWithdrawWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLendingPoolWithdraw(ctx context.Context, body CreateLendingPoolWithdrawJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogsByTransactionHash request
	GetLogsByTransactionHash(ctx context.Context, txHash string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnfilledOrders request
	GetUnfilledOrders(ctx context.Context, params *GetUnfilledOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncOrderWithBody request with any body
	SyncOrderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncOrder(ctx context.Context, body SyncOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSingleTokenPermit request
	GetSingleTokenPermit(ctx context.Context, params *GetSingleTokenPermitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScoreboard request
	GetScoreboard(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPrices request
	ListPrices(ctx context.Context, params *ListPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExitGemTransactionWithBody request with any body
	ExitGemTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExitGemTransaction(ctx context.Context, body ExitGemTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetAuctionTransactionWithBody request with any body
	ResetAuctionTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetAuctionTransaction(ctx context.Context, body ResetAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TakeAuctionTransactionWithBody request with any body
	TakeAuctionTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TakeAuctionTransaction(ctx context.Context, body TakeAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExitZarTransactionWithBody request with any body
	ExitZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExitZarTransaction(ctx context.Context, body ExitZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApproveAndJoinZarTransactionWithBody request with any body
	ApproveAndJoinZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApproveAndJoinZarTransaction(ctx context.Context, body ApproveAndJoinZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LiquidateVaultTransactionWithBody request with any body
	LiquidateVaultTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LiquidateVaultTransaction(ctx context.Context, body LiquidateVaultTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStableCoinVaultWithBody request with any body
	CreateStableCoinVaultWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateStableCoinVault(ctx context.Context, body CreateStableCoinVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DepositStableCoinCollateralWithBody request with any body
	DepositStableCoinCollateralWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DepositStableCoinCollateral(ctx context.Context, body DepositStableCoinCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MintZarTransactionWithBody request with any body
	MintZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MintZarTransaction(ctx context.Context, body MintZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RepayZarTransactionWithBody request with any body
	RepayZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RepayZarTransaction(ctx context.Context, body RepayZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WithdrawCollateralTransactionWithBody request with any body
	WithdrawCollateralTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WithdrawCollateralTransaction(ctx context.Context, body WithdrawCollateralTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStakingPlans request
	GetStakingPlans(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserStakingStats request
	GetUserStakingStats(ctx context.Context, params *GetUserStakingStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollectStakingRewardWithBody request with any body
	CollectStakingRewardWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CollectStakingReward(ctx context.Context, body CollectStakingRewardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StakeToStakingContractWithBody request with any body
	StakeToStakingContractWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StakeToStakingContract(ctx context.Context, body StakeToStakingContractJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WithdrawStakedAssetWithBody request with any body
	WithdrawStakedAssetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WithdrawStakedAsset(ctx context.Context, body WithdrawStakedAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectorData request
	GetCollectorData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSwapQuoteWithBody request with any body
	GetSwapQuoteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetSwapQuote(ctx context.Context, body GetSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVaultsByOwner request
	GetVaultsByOwner(ctx context.Context, params *GetVaultsByOwnerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVaultById request
	GetVaultById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVaultEventsById request
	GetVaultEventsById(ctx context.Context, id int, params *GetVaultEventsByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnfilledOrdersWebsocket request
	GetUnfilledOrdersWebsocket(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAccountByAddress(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountByAddressRequest(c.Server, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAddresses(ctx context.Context, params *GetAllAddressesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAddressesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllIlks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllIlksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIlkByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIlkByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserBorrows(ctx context.Context, params *GetUserBorrowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserBorrowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserDeposits(ctx context.Context, params *GetUserDepositsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserDepositsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchReserveDataByAsset(ctx context.Context, params *FetchReserveDataByAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchReserveDataByAssetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolBorrowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolBorrowRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolBorrow(ctx context.Context, body CreateLendingPoolBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolBorrowRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolDepositWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolDepositRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolDeposit(ctx context.Context, body CreateLendingPoolDepositJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolDepositRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolRepayWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolRepayRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolRepay(ctx context.Context, body CreateLendingPoolRepayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolRepayRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetLendingPoolAssetCollateralWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetLendingPoolAssetCollateralRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetLendingPoolAssetCollateral(ctx context.Context, body SetLendingPoolAssetCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetLendingPoolAssetCollateralRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolWithdrawWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolWithdrawRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolWithdraw(ctx context.Context, body CreateLendingPoolWithdrawJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolWithdrawRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogsByTransactionHash(ctx context.Context, txHash string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogsByTransactionHashRequest(c.Server, txHash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnfilledOrders(ctx context.Context, params *GetUnfilledOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnfilledOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncOrderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncOrderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncOrder(ctx context.Context, body SyncOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncOrderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSingleTokenPermit(ctx context.Context, params *GetSingleTokenPermitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSingleTokenPermitRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScoreboard(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScoreboardRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPrices(ctx context.Context, params *ListPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPricesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExitGemTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExitGemTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExitGemTransaction(ctx context.Context, body ExitGemTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExitGemTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetAuctionTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetAuctionTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetAuctionTransaction(ctx context.Context, body ResetAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetAuctionTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TakeAuctionTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTakeAuctionTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TakeAuctionTransaction(ctx context.Context, body TakeAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTakeAuctionTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExitZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExitZarTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExitZarTransaction(ctx context.Context, body ExitZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExitZarTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveAndJoinZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveAndJoinZarTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveAndJoinZarTransaction(ctx context.Context, body ApproveAndJoinZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveAndJoinZarTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LiquidateVaultTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLiquidateVaultTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LiquidateVaultTransaction(ctx context.Context, body LiquidateVaultTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLiquidateVaultTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStableCoinVaultWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStableCoinVaultRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStableCoinVault(ctx context.Context, body CreateStableCoinVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStableCoinVaultRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DepositStableCoinCollateralWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDepositStableCoinCollateralRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DepositStableCoinCollateral(ctx context.Context, body DepositStableCoinCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDepositStableCoinCollateralRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MintZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMintZarTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MintZarTransaction(ctx context.Context, body MintZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMintZarTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepayZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepayZarTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepayZarTransaction(ctx context.Context, body RepayZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepayZarTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WithdrawCollateralTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWithdrawCollateralTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WithdrawCollateralTransaction(ctx context.Context, body WithdrawCollateralTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWithdrawCollateralTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStakingPlans(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStakingPlansRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserStakingStats(ctx context.Context, params *GetUserStakingStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserStakingStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectStakingRewardWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectStakingRewardRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectStakingReward(ctx context.Context, body CollectStakingRewardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectStakingRewardRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StakeToStakingContractWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStakeToStakingContractRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StakeToStakingContract(ctx context.Context, body StakeToStakingContractJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStakeToStakingContractRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WithdrawStakedAssetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWithdrawStakedAssetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WithdrawStakedAsset(ctx context.Context, body WithdrawStakedAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWithdrawStakedAssetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectorData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectorDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSwapQuoteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSwapQuoteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSwapQuote(ctx context.Context, body GetSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSwapQuoteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVaultsByOwner(ctx context.Context, params *GetVaultsByOwnerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVaultsByOwnerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVaultById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVaultByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVaultEventsById(ctx context.Context, id int, params *GetVaultEventsByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVaultEventsByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnfilledOrdersWebsocket(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnfilledOrdersWebsocketRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAccountByAddressRequest generates requests for GetAccountByAddress
func NewGetAccountByAddressRequest(server string, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllAddressesRequest generates requests for GetAllAddresses
func NewGetAllAddressesRequest(server string, params *GetAllAddressesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/addresses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllIlksRequest generates requests for GetAllIlks
func NewGetAllIlksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/ilks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIlkByNameRequest generates requests for GetIlkByName
func NewGetIlkByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/ilks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserBorrowsRequest generates requests for GetUserBorrows
func NewGetUserBorrowsRequest(server string, params *GetUserBorrowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/borrows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reserve != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reserve", runtime.ParamLocationQuery, *params.Reserve); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserDepositsRequest generates requests for GetUserDeposits
func NewGetUserDepositsRequest(server string, params *GetUserDepositsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/deposits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reserve != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reserve", runtime.ParamLocationQuery, *params.Reserve); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchReserveDataByAssetRequest generates requests for FetchReserveDataByAsset
func NewFetchReserveDataByAssetRequest(server string, params *FetchReserveDataByAssetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/reserves")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Asset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset", runtime.ParamLocationQuery, *params.Asset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLendingPoolBorrowRequest calls the generic CreateLendingPoolBorrow builder with application/json body
func NewCreateLendingPoolBorrowRequest(server string, body CreateLendingPoolBorrowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLendingPoolBorrowRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLendingPoolBorrowRequestWithBody generates requests for CreateLendingPoolBorrow with any type of body
func NewCreateLendingPoolBorrowRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/tx/borrow")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLendingPoolDepositRequest calls the generic CreateLendingPoolDeposit builder with application/json body
func NewCreateLendingPoolDepositRequest(server string, body CreateLendingPoolDepositJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLendingPoolDepositRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLendingPoolDepositRequestWithBody generates requests for CreateLendingPoolDeposit with any type of body
func NewCreateLendingPoolDepositRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/tx/deposit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLendingPoolRepayRequest calls the generic CreateLendingPoolRepay builder with application/json body
func NewCreateLendingPoolRepayRequest(server string, body CreateLendingPoolRepayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLendingPoolRepayRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLendingPoolRepayRequestWithBody generates requests for CreateLendingPoolRepay with any type of body
func NewCreateLendingPoolRepayRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/tx/repay")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetLendingPoolAssetCollateralRequest calls the generic SetLendingPoolAssetCollateral builder with application/json body
func NewSetLendingPoolAssetCollateralRequest(server string, body SetLendingPoolAssetCollateralJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetLendingPoolAssetCollateralRequestWithBody(server, "application/json", bodyReader)
}

// NewSetLendingPoolAssetCollateralRequestWithBody generates requests for SetLendingPoolAssetCollateral with any type of body
func NewSetLendingPoolAssetCollateralRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/tx/useassetascollateral")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLendingPoolWithdrawRequest calls the generic CreateLendingPoolWithdraw builder with application/json body
func NewCreateLendingPoolWithdrawRequest(server string, body CreateLendingPoolWithdrawJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLendingPoolWithdrawRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLendingPoolWithdrawRequestWithBody generates requests for CreateLendingPoolWithdraw with any type of body
func NewCreateLendingPoolWithdrawRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/tx/withdraw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLogsByTransactionHashRequest generates requests for GetLogsByTransactionHash
func NewGetLogsByTransactionHashRequest(server string, txHash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "txHash", runtime.ParamLocationPath, txHash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/logs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUnfilledOrdersRequest generates requests for GetUnfilledOrders
func NewGetUnfilledOrdersRequest(server string, params *GetUnfilledOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hash", runtime.ParamLocationQuery, *params.Hash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offerer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offerer", runtime.ParamLocationQuery, *params.Offerer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filler != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filler", runtime.ParamLocationQuery, *params.Filler); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DecayStartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "decayStartTime", runtime.ParamLocationQuery, *params.DecayStartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DecayEndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "decayEndTime", runtime.ParamLocationQuery, *params.DecayEndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Deadline != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deadline", runtime.ParamLocationQuery, *params.Deadline); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSyncOrderRequest calls the generic SyncOrder builder with application/json body
func NewSyncOrderRequest(server string, body SyncOrderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncOrderRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncOrderRequestWithBody generates requests for SyncOrder with any type of body
func NewSyncOrderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/orders/sync")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSingleTokenPermitRequest generates requests for GetSingleTokenPermit
func NewGetSingleTokenPermitRequest(server string, params *GetSingleTokenPermitParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/permit/single")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, params.User); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScoreboardRequest generates requests for GetScoreboard
func NewGetScoreboardRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/points/scoreboard")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPricesRequest generates requests for ListPrices
func NewListPricesRequest(server string, params *ListPricesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/prices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Symbol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, *params.Symbol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExitGemTransactionRequest calls the generic ExitGemTransaction builder with application/json body
func NewExitGemTransactionRequest(server string, body ExitGemTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExitGemTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewExitGemTransactionRequestWithBody generates requests for ExitGemTransaction with any type of body
func NewExitGemTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/auctions/tx/gemexit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetAuctionTransactionRequest calls the generic ResetAuctionTransaction builder with application/json body
func NewResetAuctionTransactionRequest(server string, body ResetAuctionTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetAuctionTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewResetAuctionTransactionRequestWithBody generates requests for ResetAuctionTransaction with any type of body
func NewResetAuctionTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/auctions/tx/redo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTakeAuctionTransactionRequest calls the generic TakeAuctionTransaction builder with application/json body
func NewTakeAuctionTransactionRequest(server string, body TakeAuctionTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTakeAuctionTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewTakeAuctionTransactionRequestWithBody generates requests for TakeAuctionTransaction with any type of body
func NewTakeAuctionTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/auctions/tx/take")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExitZarTransactionRequest calls the generic ExitZarTransaction builder with application/json body
func NewExitZarTransactionRequest(server string, body ExitZarTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExitZarTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewExitZarTransactionRequestWithBody generates requests for ExitZarTransaction with any type of body
func NewExitZarTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/auctions/tx/zarexit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewApproveAndJoinZarTransactionRequest calls the generic ApproveAndJoinZarTransaction builder with application/json body
func NewApproveAndJoinZarTransactionRequest(server string, body ApproveAndJoinZarTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApproveAndJoinZarTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewApproveAndJoinZarTransactionRequestWithBody generates requests for ApproveAndJoinZarTransaction with any type of body
func NewApproveAndJoinZarTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/auctions/tx/zarjoin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLiquidateVaultTransactionRequest calls the generic LiquidateVaultTransaction builder with application/json body
func NewLiquidateVaultTransactionRequest(server string, body LiquidateVaultTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLiquidateVaultTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewLiquidateVaultTransactionRequestWithBody generates requests for LiquidateVaultTransaction with any type of body
func NewLiquidateVaultTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/tx/bark")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateStableCoinVaultRequest calls the generic CreateStableCoinVault builder with application/json body
func NewCreateStableCoinVaultRequest(server string, body CreateStableCoinVaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStableCoinVaultRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateStableCoinVaultRequestWithBody generates requests for CreateStableCoinVault with any type of body
func NewCreateStableCoinVaultRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/tx/createvault")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDepositStableCoinCollateralRequest calls the generic DepositStableCoinCollateral builder with application/json body
func NewDepositStableCoinCollateralRequest(server string, body DepositStableCoinCollateralJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDepositStableCoinCollateralRequestWithBody(server, "application/json", bodyReader)
}

// NewDepositStableCoinCollateralRequestWithBody generates requests for DepositStableCoinCollateral with any type of body
func NewDepositStableCoinCollateralRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/tx/depositcollateral")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMintZarTransactionRequest calls the generic MintZarTransaction builder with application/json body
func NewMintZarTransactionRequest(server string, body MintZarTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMintZarTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewMintZarTransactionRequestWithBody generates requests for MintZarTransaction with any type of body
func NewMintZarTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/tx/mintzar")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRepayZarTransactionRequest calls the generic RepayZarTransaction builder with application/json body
func NewRepayZarTransactionRequest(server string, body RepayZarTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRepayZarTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewRepayZarTransactionRequestWithBody generates requests for RepayZarTransaction with any type of body
func NewRepayZarTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/tx/repayzar")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWithdrawCollateralTransactionRequest calls the generic WithdrawCollateralTransaction builder with application/json body
func NewWithdrawCollateralTransactionRequest(server string, body WithdrawCollateralTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWithdrawCollateralTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewWithdrawCollateralTransactionRequestWithBody generates requests for WithdrawCollateralTransaction with any type of body
func NewWithdrawCollateralTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/tx/withdrawcollateral")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStakingPlansRequest generates requests for GetStakingPlans
func NewGetStakingPlansRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/staking/plans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserStakingStatsRequest generates requests for GetUserStakingStats
func NewGetUserStakingStatsRequest(server string, params *GetUserStakingStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/staking/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Address != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "address", runtime.ParamLocationQuery, *params.Address); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Active != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCollectStakingRewardRequest calls the generic CollectStakingReward builder with application/json body
func NewCollectStakingRewardRequest(server string, body CollectStakingRewardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCollectStakingRewardRequestWithBody(server, "application/json", bodyReader)
}

// NewCollectStakingRewardRequestWithBody generates requests for CollectStakingReward with any type of body
func NewCollectStakingRewardRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/staking/tx/collectreward")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStakeToStakingContractRequest calls the generic StakeToStakingContract builder with application/json body
func NewStakeToStakingContractRequest(server string, body StakeToStakingContractJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStakeToStakingContractRequestWithBody(server, "application/json", bodyReader)
}

// NewStakeToStakingContractRequestWithBody generates requests for StakeToStakingContract with any type of body
func NewStakeToStakingContractRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/staking/tx/stake")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWithdrawStakedAssetRequest calls the generic WithdrawStakedAsset builder with application/json body
func NewWithdrawStakedAssetRequest(server string, body WithdrawStakedAssetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWithdrawStakedAssetRequestWithBody(server, "application/json", bodyReader)
}

// NewWithdrawStakedAssetRequestWithBody generates requests for WithdrawStakedAsset with any type of body
func NewWithdrawStakedAssetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/staking/tx/withdraw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCollectorDataRequest generates requests for GetCollectorData
func NewGetCollectorDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSwapQuoteRequest calls the generic GetSwapQuote builder with application/json body
func NewGetSwapQuoteRequest(server string, body GetSwapQuoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetSwapQuoteRequestWithBody(server, "application/json", bodyReader)
}

// NewGetSwapQuoteRequestWithBody generates requests for GetSwapQuote with any type of body
func NewGetSwapQuoteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/swap/quote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVaultsByOwnerRequest generates requests for GetVaultsByOwner
func NewGetVaultsByOwnerRequest(server string, params *GetVaultsByOwnerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/vaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Owner != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner", runtime.ParamLocationQuery, *params.Owner); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVaultByIdRequest generates requests for GetVaultById
func NewGetVaultByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/vaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVaultEventsByIdRequest generates requests for GetVaultEventsById
func NewGetVaultEventsByIdRequest(server string, id int, params *GetVaultEventsByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/vaults/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUnfilledOrdersWebsocketRequest generates requests for GetUnfilledOrdersWebsocket
func NewGetUnfilledOrdersWebsocketRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/ws")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAccountByAddressWithResponse request
	GetAccountByAddressWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetAccountByAddressResponse, error)

	// GetAllAddressesWithResponse request
	GetAllAddressesWithResponse(ctx context.Context, params *GetAllAddressesParams, reqEditors ...RequestEditorFn) (*GetAllAddressesResponse, error)

	// GetAllIlksWithResponse request
	GetAllIlksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllIlksResponse, error)

	// GetIlkByNameWithResponse request
	GetIlkByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetIlkByNameResponse, error)

	// GetUserBorrowsWithResponse request
	GetUserBorrowsWithResponse(ctx context.Context, params *GetUserBorrowsParams, reqEditors ...RequestEditorFn) (*GetUserBorrowsResponse, error)

	// GetUserDepositsWithResponse request
	GetUserDepositsWithResponse(ctx context.Context, params *GetUserDepositsParams, reqEditors ...RequestEditorFn) (*GetUserDepositsResponse, error)

	// FetchReserveDataByAssetWithResponse request
	FetchReserveDataByAssetWithResponse(ctx context.Context, params *FetchReserveDataByAssetParams, reqEditors ...RequestEditorFn) (*FetchReserveDataByAssetResponse, error)

	// CreateLendingPoolBorrowWithBodyWithResponse request with any body
	CreateLendingPoolBorrowWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolBorrowResponse, error)

	CreateLendingPoolBorrowWithResponse(ctx context.Context, body CreateLendingPoolBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolBorrowResponse, error)

	// CreateLendingPoolDepositWithBodyWithResponse request with any body
	CreateLendingPoolDepositWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolDepositResponse, error)

	CreateLendingPoolDepositWithResponse(ctx context.Context, body CreateLendingPoolDepositJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolDepositResponse, error)

	// CreateLendingPoolRepayWithBodyWithResponse request with any body
	CreateLendingPoolRepayWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolRepayResponse, error)

	CreateLendingPoolRepayWithResponse(ctx context.Context, body CreateLendingPoolRepayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolRepayResponse, error)

	// SetLendingPoolAssetCollateralWithBodyWithResponse request with any body
	SetLendingPoolAssetCollateralWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetLendingPoolAssetCollateralResponse, error)

	SetLendingPoolAssetCollateralWithResponse(ctx context.Context, body SetLendingPoolAssetCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*SetLendingPoolAssetCollateralResponse, error)

	// CreateLendingPoolWithdrawWithBodyWithResponse request with any body
	CreateLendingPoolWithdrawWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolWithdrawResponse, error)

	CreateLendingPoolWithdrawWithResponse(ctx context.Context, body CreateLendingPoolWithdrawJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolWithdrawResponse, error)

	// GetLogsByTransactionHashWithResponse request
	GetLogsByTransactionHashWithResponse(ctx context.Context, txHash string, reqEditors ...RequestEditorFn) (*GetLogsByTransactionHashResponse, error)

	// GetUnfilledOrdersWithResponse request
	GetUnfilledOrdersWithResponse(ctx context.Context, params *GetUnfilledOrdersParams, reqEditors ...RequestEditorFn) (*GetUnfilledOrdersResponse, error)

	// SyncOrderWithBodyWithResponse request with any body
	SyncOrderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncOrderResponse, error)

	SyncOrderWithResponse(ctx context.Context, body SyncOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncOrderResponse, error)

	// GetSingleTokenPermitWithResponse request
	GetSingleTokenPermitWithResponse(ctx context.Context, params *GetSingleTokenPermitParams, reqEditors ...RequestEditorFn) (*GetSingleTokenPermitResponse, error)

	// GetScoreboardWithResponse request
	GetScoreboardWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetScoreboardResponse, error)

	// ListPricesWithResponse request
	ListPricesWithResponse(ctx context.Context, params *ListPricesParams, reqEditors ...RequestEditorFn) (*ListPricesResponse, error)

	// ExitGemTransactionWithBodyWithResponse request with any body
	ExitGemTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExitGemTransactionResponse, error)

	ExitGemTransactionWithResponse(ctx context.Context, body ExitGemTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExitGemTransactionResponse, error)

	// ResetAuctionTransactionWithBodyWithResponse request with any body
	ResetAuctionTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetAuctionTransactionResponse, error)

	ResetAuctionTransactionWithResponse(ctx context.Context, body ResetAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetAuctionTransactionResponse, error)

	// TakeAuctionTransactionWithBodyWithResponse request with any body
	TakeAuctionTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TakeAuctionTransactionResponse, error)

	TakeAuctionTransactionWithResponse(ctx context.Context, body TakeAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TakeAuctionTransactionResponse, error)

	// ExitZarTransactionWithBodyWithResponse request with any body
	ExitZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExitZarTransactionResponse, error)

	ExitZarTransactionWithResponse(ctx context.Context, body ExitZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExitZarTransactionResponse, error)

	// ApproveAndJoinZarTransactionWithBodyWithResponse request with any body
	ApproveAndJoinZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApproveAndJoinZarTransactionResponse, error)

	ApproveAndJoinZarTransactionWithResponse(ctx context.Context, body ApproveAndJoinZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ApproveAndJoinZarTransactionResponse, error)

	// LiquidateVaultTransactionWithBodyWithResponse request with any body
	LiquidateVaultTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LiquidateVaultTransactionResponse, error)

	LiquidateVaultTransactionWithResponse(ctx context.Context, body LiquidateVaultTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*LiquidateVaultTransactionResponse, error)

	// CreateStableCoinVaultWithBodyWithResponse request with any body
	CreateStableCoinVaultWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStableCoinVaultResponse, error)

	CreateStableCoinVaultWithResponse(ctx context.Context, body CreateStableCoinVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStableCoinVaultResponse, error)

	// DepositStableCoinCollateralWithBodyWithResponse request with any body
	DepositStableCoinCollateralWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DepositStableCoinCollateralResponse, error)

	DepositStableCoinCollateralWithResponse(ctx context.Context, body DepositStableCoinCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*DepositStableCoinCollateralResponse, error)

	// MintZarTransactionWithBodyWithResponse request with any body
	MintZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MintZarTransactionResponse, error)

	MintZarTransactionWithResponse(ctx context.Context, body MintZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*MintZarTransactionResponse, error)

	// RepayZarTransactionWithBodyWithResponse request with any body
	RepayZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepayZarTransactionResponse, error)

	RepayZarTransactionWithResponse(ctx context.Context, body RepayZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*RepayZarTransactionResponse, error)

	// WithdrawCollateralTransactionWithBodyWithResponse request with any body
	WithdrawCollateralTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WithdrawCollateralTransactionResponse, error)

	WithdrawCollateralTransactionWithResponse(ctx context.Context, body WithdrawCollateralTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*WithdrawCollateralTransactionResponse, error)

	// GetStakingPlansWithResponse request
	GetStakingPlansWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStakingPlansResponse, error)

	// GetUserStakingStatsWithResponse request
	GetUserStakingStatsWithResponse(ctx context.Context, params *GetUserStakingStatsParams, reqEditors ...RequestEditorFn) (*GetUserStakingStatsResponse, error)

	// CollectStakingRewardWithBodyWithResponse request with any body
	CollectStakingRewardWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollectStakingRewardResponse, error)

	CollectStakingRewardWithResponse(ctx context.Context, body CollectStakingRewardJSONRequestBody, reqEditors ...RequestEditorFn) (*CollectStakingRewardResponse, error)

	// StakeToStakingContractWithBodyWithResponse request with any body
	StakeToStakingContractWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StakeToStakingContractResponse, error)

	StakeToStakingContractWithResponse(ctx context.Context, body StakeToStakingContractJSONRequestBody, reqEditors ...RequestEditorFn) (*StakeToStakingContractResponse, error)

	// WithdrawStakedAssetWithBodyWithResponse request with any body
	WithdrawStakedAssetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WithdrawStakedAssetResponse, error)

	WithdrawStakedAssetWithResponse(ctx context.Context, body WithdrawStakedAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*WithdrawStakedAssetResponse, error)

	// GetCollectorDataWithResponse request
	GetCollectorDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCollectorDataResponse, error)

	// GetSwapQuoteWithBodyWithResponse request with any body
	GetSwapQuoteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetSwapQuoteResponse, error)

	GetSwapQuoteWithResponse(ctx context.Context, body GetSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSwapQuoteResponse, error)

	// GetVaultsByOwnerWithResponse request
	GetVaultsByOwnerWithResponse(ctx context.Context, params *GetVaultsByOwnerParams, reqEditors ...RequestEditorFn) (*GetVaultsByOwnerResponse, error)

	// GetVaultByIdWithResponse request
	GetVaultByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetVaultByIdResponse, error)

	// GetVaultEventsByIdWithResponse request
	GetVaultEventsByIdWithResponse(ctx context.Context, id int, params *GetVaultEventsByIdParams, reqEditors ...RequestEditorFn) (*GetVaultEventsByIdResponse, error)

	// GetUnfilledOrdersWebsocketWithResponse request
	GetUnfilledOrdersWebsocketWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUnfilledOrdersWebsocketResponse, error)
}

type GetAccountByAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Account
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAccountByAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountByAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAddressesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddressResponse
}

// Status returns HTTPResponse.Status
func (r GetAllAddressesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAddressesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllIlksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IlksResponse
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAllIlksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllIlksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIlkByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ilk
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetIlkByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIlkByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserBorrowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserBorrowsResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUserBorrowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserBorrowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserDepositsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserDepositsResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUserDepositsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserDepositsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchReserveDataByAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FormattedReserveData
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r FetchReserveDataByAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchReserveDataByAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLendingPoolBorrowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LendingpoolBorrowTxResponse
	JSON400      *UserError
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateLendingPoolBorrowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLendingPoolBorrowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLendingPoolDepositResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LendingpoolDepositTxResponse
	JSON400      *UserError
	JSON500      *UserError
}

// Status returns HTTPResponse.Status
func (r CreateLendingPoolDepositResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLendingPoolDepositResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLendingPoolRepayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LendingpoolRepayTxResponse
	JSON400      *UserError
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateLendingPoolRepayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLendingPoolRepayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetLendingPoolAssetCollateralResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LendingpoolUseAssetAsCollateralTxResponse
	JSON400      *UserError
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r SetLendingPoolAssetCollateralResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetLendingPoolAssetCollateralResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLendingPoolWithdrawResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LendingpoolWithdrawTxResponse
	JSON400      *UserError
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateLendingPoolWithdrawResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLendingPoolWithdrawResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogsByTransactionHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventDetailsResponse
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLogsByTransactionHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogsByTransactionHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnfilledOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUnfilledOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnfilledOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Error
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r SyncOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSingleTokenPermitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermitSingle
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSingleTokenPermitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSingleTokenPermitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScoreboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Scoreboard
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetScoreboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScoreboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPricesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PriceListResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListPricesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPricesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExitGemTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ExitGemTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExitGemTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetAuctionTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ResetAuctionTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetAuctionTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TakeAuctionTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r TakeAuctionTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TakeAuctionTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExitZarTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ExitZarTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExitZarTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApproveAndJoinZarTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ApproveAndJoinZarTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApproveAndJoinZarTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LiquidateVaultTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r LiquidateVaultTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LiquidateVaultTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStableCoinVaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateStableCoinVaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStableCoinVaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DepositStableCoinCollateralResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DepositStableCoinCollateralResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DepositStableCoinCollateralResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MintZarTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r MintZarTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MintZarTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RepayZarTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RepayZarTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RepayZarTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WithdrawCollateralTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r WithdrawCollateralTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WithdrawCollateralTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStakingPlansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StakePlansResponse
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetStakingPlansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStakingPlansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserStakingStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserStakesResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUserStakingStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserStakingStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollectStakingRewardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StakingCollectRewardTxResponse
	JSON400      *UserError
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CollectStakingRewardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectStakingRewardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StakeToStakingContractResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StakingStakeTxResponse
	JSON400      *UserError
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r StakeToStakingContractResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StakeToStakingContractResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WithdrawStakedAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StakingWithdrawTxResponse
	JSON400      *UserError
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r WithdrawStakedAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WithdrawStakedAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectorDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Stats
}

// Status returns HTTPResponse.Status
func (r GetCollectorDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectorDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSwapQuoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuoteResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSwapQuoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSwapQuoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVaultsByOwnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VaultsResponse
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVaultsByOwnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVaultsByOwnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVaultByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Vault
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVaultByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVaultByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVaultEventsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VaultEventsResponse
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVaultEventsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVaultEventsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnfilledOrdersWebsocketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetUnfilledOrdersWebsocketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnfilledOrdersWebsocketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAccountByAddressWithResponse request returning *GetAccountByAddressResponse
func (c *ClientWithResponses) GetAccountByAddressWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetAccountByAddressResponse, error) {
	rsp, err := c.GetAccountByAddress(ctx, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountByAddressResponse(rsp)
}

// GetAllAddressesWithResponse request returning *GetAllAddressesResponse
func (c *ClientWithResponses) GetAllAddressesWithResponse(ctx context.Context, params *GetAllAddressesParams, reqEditors ...RequestEditorFn) (*GetAllAddressesResponse, error) {
	rsp, err := c.GetAllAddresses(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAddressesResponse(rsp)
}

// GetAllIlksWithResponse request returning *GetAllIlksResponse
func (c *ClientWithResponses) GetAllIlksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllIlksResponse, error) {
	rsp, err := c.GetAllIlks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllIlksResponse(rsp)
}

// GetIlkByNameWithResponse request returning *GetIlkByNameResponse
func (c *ClientWithResponses) GetIlkByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetIlkByNameResponse, error) {
	rsp, err := c.GetIlkByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIlkByNameResponse(rsp)
}

// GetUserBorrowsWithResponse request returning *GetUserBorrowsResponse
func (c *ClientWithResponses) GetUserBorrowsWithResponse(ctx context.Context, params *GetUserBorrowsParams, reqEditors ...RequestEditorFn) (*GetUserBorrowsResponse, error) {
	rsp, err := c.GetUserBorrows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserBorrowsResponse(rsp)
}

// GetUserDepositsWithResponse request returning *GetUserDepositsResponse
func (c *ClientWithResponses) GetUserDepositsWithResponse(ctx context.Context, params *GetUserDepositsParams, reqEditors ...RequestEditorFn) (*GetUserDepositsResponse, error) {
	rsp, err := c.GetUserDeposits(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserDepositsResponse(rsp)
}

// FetchReserveDataByAssetWithResponse request returning *FetchReserveDataByAssetResponse
func (c *ClientWithResponses) FetchReserveDataByAssetWithResponse(ctx context.Context, params *FetchReserveDataByAssetParams, reqEditors ...RequestEditorFn) (*FetchReserveDataByAssetResponse, error) {
	rsp, err := c.FetchReserveDataByAsset(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchReserveDataByAssetResponse(rsp)
}

// CreateLendingPoolBorrowWithBodyWithResponse request with arbitrary body returning *CreateLendingPoolBorrowResponse
func (c *ClientWithResponses) CreateLendingPoolBorrowWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolBorrowResponse, error) {
	rsp, err := c.CreateLendingPoolBorrowWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolBorrowResponse(rsp)
}

func (c *ClientWithResponses) CreateLendingPoolBorrowWithResponse(ctx context.Context, body CreateLendingPoolBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolBorrowResponse, error) {
	rsp, err := c.CreateLendingPoolBorrow(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolBorrowResponse(rsp)
}

// CreateLendingPoolDepositWithBodyWithResponse request with arbitrary body returning *CreateLendingPoolDepositResponse
func (c *ClientWithResponses) CreateLendingPoolDepositWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolDepositResponse, error) {
	rsp, err := c.CreateLendingPoolDepositWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolDepositResponse(rsp)
}

func (c *ClientWithResponses) CreateLendingPoolDepositWithResponse(ctx context.Context, body CreateLendingPoolDepositJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolDepositResponse, error) {
	rsp, err := c.CreateLendingPoolDeposit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolDepositResponse(rsp)
}

// CreateLendingPoolRepayWithBodyWithResponse request with arbitrary body returning *CreateLendingPoolRepayResponse
func (c *ClientWithResponses) CreateLendingPoolRepayWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolRepayResponse, error) {
	rsp, err := c.CreateLendingPoolRepayWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolRepayResponse(rsp)
}

func (c *ClientWithResponses) CreateLendingPoolRepayWithResponse(ctx context.Context, body CreateLendingPoolRepayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolRepayResponse, error) {
	rsp, err := c.CreateLendingPoolRepay(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolRepayResponse(rsp)
}

// SetLendingPoolAssetCollateralWithBodyWithResponse request with arbitrary body returning *SetLendingPoolAssetCollateralResponse
func (c *ClientWithResponses) SetLendingPoolAssetCollateralWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetLendingPoolAssetCollateralResponse, error) {
	rsp, err := c.SetLendingPoolAssetCollateralWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetLendingPoolAssetCollateralResponse(rsp)
}

func (c *ClientWithResponses) SetLendingPoolAssetCollateralWithResponse(ctx context.Context, body SetLendingPoolAssetCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*SetLendingPoolAssetCollateralResponse, error) {
	rsp, err := c.SetLendingPoolAssetCollateral(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetLendingPoolAssetCollateralResponse(rsp)
}

// CreateLendingPoolWithdrawWithBodyWithResponse request with arbitrary body returning *CreateLendingPoolWithdrawResponse
func (c *ClientWithResponses) CreateLendingPoolWithdrawWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolWithdrawResponse, error) {
	rsp, err := c.CreateLendingPoolWithdrawWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolWithdrawResponse(rsp)
}

func (c *ClientWithResponses) CreateLendingPoolWithdrawWithResponse(ctx context.Context, body CreateLendingPoolWithdrawJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolWithdrawResponse, error) {
	rsp, err := c.CreateLendingPoolWithdraw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolWithdrawResponse(rsp)
}

// GetLogsByTransactionHashWithResponse request returning *GetLogsByTransactionHashResponse
func (c *ClientWithResponses) GetLogsByTransactionHashWithResponse(ctx context.Context, txHash string, reqEditors ...RequestEditorFn) (*GetLogsByTransactionHashResponse, error) {
	rsp, err := c.GetLogsByTransactionHash(ctx, txHash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogsByTransactionHashResponse(rsp)
}

// GetUnfilledOrdersWithResponse request returning *GetUnfilledOrdersResponse
func (c *ClientWithResponses) GetUnfilledOrdersWithResponse(ctx context.Context, params *GetUnfilledOrdersParams, reqEditors ...RequestEditorFn) (*GetUnfilledOrdersResponse, error) {
	rsp, err := c.GetUnfilledOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUnfilledOrdersResponse(rsp)
}

// SyncOrderWithBodyWithResponse request with arbitrary body returning *SyncOrderResponse
func (c *ClientWithResponses) SyncOrderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncOrderResponse, error) {
	rsp, err := c.SyncOrderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncOrderResponse(rsp)
}

func (c *ClientWithResponses) SyncOrderWithResponse(ctx context.Context, body SyncOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncOrderResponse, error) {
	rsp, err := c.SyncOrder(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncOrderResponse(rsp)
}

// GetSingleTokenPermitWithResponse request returning *GetSingleTokenPermitResponse
func (c *ClientWithResponses) GetSingleTokenPermitWithResponse(ctx context.Context, params *GetSingleTokenPermitParams, reqEditors ...RequestEditorFn) (*GetSingleTokenPermitResponse, error) {
	rsp, err := c.GetSingleTokenPermit(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSingleTokenPermitResponse(rsp)
}

// GetScoreboardWithResponse request returning *GetScoreboardResponse
func (c *ClientWithResponses) GetScoreboardWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetScoreboardResponse, error) {
	rsp, err := c.GetScoreboard(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScoreboardResponse(rsp)
}

// ListPricesWithResponse request returning *ListPricesResponse
func (c *ClientWithResponses) ListPricesWithResponse(ctx context.Context, params *ListPricesParams, reqEditors ...RequestEditorFn) (*ListPricesResponse, error) {
	rsp, err := c.ListPrices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPricesResponse(rsp)
}

// ExitGemTransactionWithBodyWithResponse request with arbitrary body returning *ExitGemTransactionResponse
func (c *ClientWithResponses) ExitGemTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExitGemTransactionResponse, error) {
	rsp, err := c.ExitGemTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExitGemTransactionResponse(rsp)
}

func (c *ClientWithResponses) ExitGemTransactionWithResponse(ctx context.Context, body ExitGemTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExitGemTransactionResponse, error) {
	rsp, err := c.ExitGemTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExitGemTransactionResponse(rsp)
}

// ResetAuctionTransactionWithBodyWithResponse request with arbitrary body returning *ResetAuctionTransactionResponse
func (c *ClientWithResponses) ResetAuctionTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetAuctionTransactionResponse, error) {
	rsp, err := c.ResetAuctionTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetAuctionTransactionResponse(rsp)
}

func (c *ClientWithResponses) ResetAuctionTransactionWithResponse(ctx context.Context, body ResetAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetAuctionTransactionResponse, error) {
	rsp, err := c.ResetAuctionTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetAuctionTransactionResponse(rsp)
}

// TakeAuctionTransactionWithBodyWithResponse request with arbitrary body returning *TakeAuctionTransactionResponse
func (c *ClientWithResponses) TakeAuctionTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TakeAuctionTransactionResponse, error) {
	rsp, err := c.TakeAuctionTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTakeAuctionTransactionResponse(rsp)
}

func (c *ClientWithResponses) TakeAuctionTransactionWithResponse(ctx context.Context, body TakeAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TakeAuctionTransactionResponse, error) {
	rsp, err := c.TakeAuctionTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTakeAuctionTransactionResponse(rsp)
}

// ExitZarTransactionWithBodyWithResponse request with arbitrary body returning *ExitZarTransactionResponse
func (c *ClientWithResponses) ExitZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExitZarTransactionResponse, error) {
	rsp, err := c.ExitZarTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExitZarTransactionResponse(rsp)
}

func (c *ClientWithResponses) ExitZarTransactionWithResponse(ctx context.Context, body ExitZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExitZarTransactionResponse, error) {
	rsp, err := c.ExitZarTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExitZarTransactionResponse(rsp)
}

// ApproveAndJoinZarTransactionWithBodyWithResponse request with arbitrary body returning *ApproveAndJoinZarTransactionResponse
func (c *ClientWithResponses) ApproveAndJoinZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApproveAndJoinZarTransactionResponse, error) {
	rsp, err := c.ApproveAndJoinZarTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveAndJoinZarTransactionResponse(rsp)
}

func (c *ClientWithResponses) ApproveAndJoinZarTransactionWithResponse(ctx context.Context, body ApproveAndJoinZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ApproveAndJoinZarTransactionResponse, error) {
	rsp, err := c.ApproveAndJoinZarTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveAndJoinZarTransactionResponse(rsp)
}

// LiquidateVaultTransactionWithBodyWithResponse request with arbitrary body returning *LiquidateVaultTransactionResponse
func (c *ClientWithResponses) LiquidateVaultTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LiquidateVaultTransactionResponse, error) {
	rsp, err := c.LiquidateVaultTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLiquidateVaultTransactionResponse(rsp)
}

func (c *ClientWithResponses) LiquidateVaultTransactionWithResponse(ctx context.Context, body LiquidateVaultTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*LiquidateVaultTransactionResponse, error) {
	rsp, err := c.LiquidateVaultTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLiquidateVaultTransactionResponse(rsp)
}

// CreateStableCoinVaultWithBodyWithResponse request with arbitrary body returning *CreateStableCoinVaultResponse
func (c *ClientWithResponses) CreateStableCoinVaultWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStableCoinVaultResponse, error) {
	rsp, err := c.CreateStableCoinVaultWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStableCoinVaultResponse(rsp)
}

func (c *ClientWithResponses) CreateStableCoinVaultWithResponse(ctx context.Context, body CreateStableCoinVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStableCoinVaultResponse, error) {
	rsp, err := c.CreateStableCoinVault(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStableCoinVaultResponse(rsp)
}

// DepositStableCoinCollateralWithBodyWithResponse request with arbitrary body returning *DepositStableCoinCollateralResponse
func (c *ClientWithResponses) DepositStableCoinCollateralWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DepositStableCoinCollateralResponse, error) {
	rsp, err := c.DepositStableCoinCollateralWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDepositStableCoinCollateralResponse(rsp)
}

func (c *ClientWithResponses) DepositStableCoinCollateralWithResponse(ctx context.Context, body DepositStableCoinCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*DepositStableCoinCollateralResponse, error) {
	rsp, err := c.DepositStableCoinCollateral(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDepositStableCoinCollateralResponse(rsp)
}

// MintZarTransactionWithBodyWithResponse request with arbitrary body returning *MintZarTransactionResponse
func (c *ClientWithResponses) MintZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MintZarTransactionResponse, error) {
	rsp, err := c.MintZarTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMintZarTransactionResponse(rsp)
}

func (c *ClientWithResponses) MintZarTransactionWithResponse(ctx context.Context, body MintZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*MintZarTransactionResponse, error) {
	rsp, err := c.MintZarTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMintZarTransactionResponse(rsp)
}

// RepayZarTransactionWithBodyWithResponse request with arbitrary body returning *RepayZarTransactionResponse
func (c *ClientWithResponses) RepayZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepayZarTransactionResponse, error) {
	rsp, err := c.RepayZarTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepayZarTransactionResponse(rsp)
}

func (c *ClientWithResponses) RepayZarTransactionWithResponse(ctx context.Context, body RepayZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*RepayZarTransactionResponse, error) {
	rsp, err := c.RepayZarTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepayZarTransactionResponse(rsp)
}

// WithdrawCollateralTransactionWithBodyWithResponse request with arbitrary body returning *WithdrawCollateralTransactionResponse
func (c *ClientWithResponses) WithdrawCollateralTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WithdrawCollateralTransactionResponse, error) {
	rsp, err := c.WithdrawCollateralTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWithdrawCollateralTransactionResponse(rsp)
}

func (c *ClientWithResponses) WithdrawCollateralTransactionWithResponse(ctx context.Context, body WithdrawCollateralTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*WithdrawCollateralTransactionResponse, error) {
	rsp, err := c.WithdrawCollateralTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWithdrawCollateralTransactionResponse(rsp)
}

// GetStakingPlansWithResponse request returning *GetStakingPlansResponse
func (c *ClientWithResponses) GetStakingPlansWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStakingPlansResponse, error) {
	rsp, err := c.GetStakingPlans(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStakingPlansResponse(rsp)
}

// GetUserStakingStatsWithResponse request returning *GetUserStakingStatsResponse
func (c *ClientWithResponses) GetUserStakingStatsWithResponse(ctx context.Context, params *GetUserStakingStatsParams, reqEditors ...RequestEditorFn) (*GetUserStakingStatsResponse, error) {
	rsp, err := c.GetUserStakingStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserStakingStatsResponse(rsp)
}

// CollectStakingRewardWithBodyWithResponse request with arbitrary body returning *CollectStakingRewardResponse
func (c *ClientWithResponses) CollectStakingRewardWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollectStakingRewardResponse, error) {
	rsp, err := c.CollectStakingRewardWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectStakingRewardResponse(rsp)
}

func (c *ClientWithResponses) CollectStakingRewardWithResponse(ctx context.Context, body CollectStakingRewardJSONRequestBody, reqEditors ...RequestEditorFn) (*CollectStakingRewardResponse, error) {
	rsp, err := c.CollectStakingReward(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectStakingRewardResponse(rsp)
}

// StakeToStakingContractWithBodyWithResponse request with arbitrary body returning *StakeToStakingContractResponse
func (c *ClientWithResponses) StakeToStakingContractWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StakeToStakingContractResponse, error) {
	rsp, err := c.StakeToStakingContractWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStakeToStakingContractResponse(rsp)
}

func (c *ClientWithResponses) StakeToStakingContractWithResponse(ctx context.Context, body StakeToStakingContractJSONRequestBody, reqEditors ...RequestEditorFn) (*StakeToStakingContractResponse, error) {
	rsp, err := c.StakeToStakingContract(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStakeToStakingContractResponse(rsp)
}

// WithdrawStakedAssetWithBodyWithResponse request with arbitrary body returning *WithdrawStakedAssetResponse
func (c *ClientWithResponses) WithdrawStakedAssetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WithdrawStakedAssetResponse, error) {
	rsp, err := c.WithdrawStakedAssetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWithdrawStakedAssetResponse(rsp)
}

func (c *ClientWithResponses) WithdrawStakedAssetWithResponse(ctx context.Context, body WithdrawStakedAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*WithdrawStakedAssetResponse, error) {
	rsp, err := c.WithdrawStakedAsset(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWithdrawStakedAssetResponse(rsp)
}

// GetCollectorDataWithResponse request returning *GetCollectorDataResponse
func (c *ClientWithResponses) GetCollectorDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCollectorDataResponse, error) {
	rsp, err := c.GetCollectorData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectorDataResponse(rsp)
}

// GetSwapQuoteWithBodyWithResponse request with arbitrary body returning *GetSwapQuoteResponse
func (c *ClientWithResponses) GetSwapQuoteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetSwapQuoteResponse, error) {
	rsp, err := c.GetSwapQuoteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSwapQuoteResponse(rsp)
}

func (c *ClientWithResponses) GetSwapQuoteWithResponse(ctx context.Context, body GetSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSwapQuoteResponse, error) {
	rsp, err := c.GetSwapQuote(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSwapQuoteResponse(rsp)
}

// GetVaultsByOwnerWithResponse request returning *GetVaultsByOwnerResponse
func (c *ClientWithResponses) GetVaultsByOwnerWithResponse(ctx context.Context, params *GetVaultsByOwnerParams, reqEditors ...RequestEditorFn) (*GetVaultsByOwnerResponse, error) {
	rsp, err := c.GetVaultsByOwner(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVaultsByOwnerResponse(rsp)
}

// GetVaultByIdWithResponse request returning *GetVaultByIdResponse
func (c *ClientWithResponses) GetVaultByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetVaultByIdResponse, error) {
	rsp, err := c.GetVaultById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVaultByIdResponse(rsp)
}

// GetVaultEventsByIdWithResponse request returning *GetVaultEventsByIdResponse
func (c *ClientWithResponses) GetVaultEventsByIdWithResponse(ctx context.Context, id int, params *GetVaultEventsByIdParams, reqEditors ...RequestEditorFn) (*GetVaultEventsByIdResponse, error) {
	rsp, err := c.GetVaultEventsById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVaultEventsByIdResponse(rsp)
}

// GetUnfilledOrdersWebsocketWithResponse request returning *GetUnfilledOrdersWebsocketResponse
func (c *ClientWithResponses) GetUnfilledOrdersWebsocketWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUnfilledOrdersWebsocketResponse, error) {
	rsp, err := c.GetUnfilledOrdersWebsocket(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUnfilledOrdersWebsocketResponse(rsp)
}

// ParseGetAccountByAddressResponse parses an HTTP response from a GetAccountByAddressWithResponse call
func ParseGetAccountByAddressResponse(rsp *http.Response) (*GetAccountByAddressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountByAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Account
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllAddressesResponse parses an HTTP response from a GetAllAddressesWithResponse call
func ParseGetAllAddressesResponse(rsp *http.Response) (*GetAllAddressesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAddressesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllIlksResponse parses an HTTP response from a GetAllIlksWithResponse call
func ParseGetAllIlksResponse(rsp *http.Response) (*GetAllIlksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllIlksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IlksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetIlkByNameResponse parses an HTTP response from a GetIlkByNameWithResponse call
func ParseGetIlkByNameResponse(rsp *http.Response) (*GetIlkByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIlkByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ilk
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserBorrowsResponse parses an HTTP response from a GetUserBorrowsWithResponse call
func ParseGetUserBorrowsResponse(rsp *http.Response) (*GetUserBorrowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserBorrowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserBorrowsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserDepositsResponse parses an HTTP response from a GetUserDepositsWithResponse call
func ParseGetUserDepositsResponse(rsp *http.Response) (*GetUserDepositsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserDepositsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserDepositsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFetchReserveDataByAssetResponse parses an HTTP response from a FetchReserveDataByAssetWithResponse call
func ParseFetchReserveDataByAssetResponse(rsp *http.Response) (*FetchReserveDataByAssetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchReserveDataByAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FormattedReserveData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateLendingPoolBorrowResponse parses an HTTP response from a CreateLendingPoolBorrowWithResponse call
func ParseCreateLendingPoolBorrowResponse(rsp *http.Response) (*CreateLendingPoolBorrowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLendingPoolBorrowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LendingpoolBorrowTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateLendingPoolDepositResponse parses an HTTP response from a CreateLendingPoolDepositWithResponse call
func ParseCreateLendingPoolDepositResponse(rsp *http.Response) (*CreateLendingPoolDepositResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLendingPoolDepositResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LendingpoolDepositTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateLendingPoolRepayResponse parses an HTTP response from a CreateLendingPoolRepayWithResponse call
func ParseCreateLendingPoolRepayResponse(rsp *http.Response) (*CreateLendingPoolRepayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLendingPoolRepayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LendingpoolRepayTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetLendingPoolAssetCollateralResponse parses an HTTP response from a SetLendingPoolAssetCollateralWithResponse call
func ParseSetLendingPoolAssetCollateralResponse(rsp *http.Response) (*SetLendingPoolAssetCollateralResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetLendingPoolAssetCollateralResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LendingpoolUseAssetAsCollateralTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateLendingPoolWithdrawResponse parses an HTTP response from a CreateLendingPoolWithdrawWithResponse call
func ParseCreateLendingPoolWithdrawResponse(rsp *http.Response) (*CreateLendingPoolWithdrawResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLendingPoolWithdrawResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LendingpoolWithdrawTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLogsByTransactionHashResponse parses an HTTP response from a GetLogsByTransactionHashWithResponse call
func ParseGetLogsByTransactionHashResponse(rsp *http.Response) (*GetLogsByTransactionHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogsByTransactionHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUnfilledOrdersResponse parses an HTTP response from a GetUnfilledOrdersWithResponse call
func ParseGetUnfilledOrdersResponse(rsp *http.Response) (*GetUnfilledOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUnfilledOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSyncOrderResponse parses an HTTP response from a SyncOrderWithResponse call
func ParseSyncOrderResponse(rsp *http.Response) (*SyncOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSingleTokenPermitResponse parses an HTTP response from a GetSingleTokenPermitWithResponse call
func ParseGetSingleTokenPermitResponse(rsp *http.Response) (*GetSingleTokenPermitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSingleTokenPermitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermitSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetScoreboardResponse parses an HTTP response from a GetScoreboardWithResponse call
func ParseGetScoreboardResponse(rsp *http.Response) (*GetScoreboardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScoreboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Scoreboard
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPricesResponse parses an HTTP response from a ListPricesWithResponse call
func ParseListPricesResponse(rsp *http.Response) (*ListPricesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPricesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PriceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExitGemTransactionResponse parses an HTTP response from a ExitGemTransactionWithResponse call
func ParseExitGemTransactionResponse(rsp *http.Response) (*ExitGemTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExitGemTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseResetAuctionTransactionResponse parses an HTTP response from a ResetAuctionTransactionWithResponse call
func ParseResetAuctionTransactionResponse(rsp *http.Response) (*ResetAuctionTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetAuctionTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTakeAuctionTransactionResponse parses an HTTP response from a TakeAuctionTransactionWithResponse call
func ParseTakeAuctionTransactionResponse(rsp *http.Response) (*TakeAuctionTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TakeAuctionTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExitZarTransactionResponse parses an HTTP response from a ExitZarTransactionWithResponse call
func ParseExitZarTransactionResponse(rsp *http.Response) (*ExitZarTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExitZarTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseApproveAndJoinZarTransactionResponse parses an HTTP response from a ApproveAndJoinZarTransactionWithResponse call
func ParseApproveAndJoinZarTransactionResponse(rsp *http.Response) (*ApproveAndJoinZarTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApproveAndJoinZarTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLiquidateVaultTransactionResponse parses an HTTP response from a LiquidateVaultTransactionWithResponse call
func ParseLiquidateVaultTransactionResponse(rsp *http.Response) (*LiquidateVaultTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LiquidateVaultTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateStableCoinVaultResponse parses an HTTP response from a CreateStableCoinVaultWithResponse call
func ParseCreateStableCoinVaultResponse(rsp *http.Response) (*CreateStableCoinVaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStableCoinVaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDepositStableCoinCollateralResponse parses an HTTP response from a DepositStableCoinCollateralWithResponse call
func ParseDepositStableCoinCollateralResponse(rsp *http.Response) (*DepositStableCoinCollateralResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DepositStableCoinCollateralResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMintZarTransactionResponse parses an HTTP response from a MintZarTransactionWithResponse call
func ParseMintZarTransactionResponse(rsp *http.Response) (*MintZarTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MintZarTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRepayZarTransactionResponse parses an HTTP response from a RepayZarTransactionWithResponse call
func ParseRepayZarTransactionResponse(rsp *http.Response) (*RepayZarTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RepayZarTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWithdrawCollateralTransactionResponse parses an HTTP response from a WithdrawCollateralTransactionWithResponse call
func ParseWithdrawCollateralTransactionResponse(rsp *http.Response) (*WithdrawCollateralTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WithdrawCollateralTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStakingPlansResponse parses an HTTP response from a GetStakingPlansWithResponse call
func ParseGetStakingPlansResponse(rsp *http.Response) (*GetStakingPlansResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStakingPlansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StakePlansResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserStakingStatsResponse parses an HTTP response from a GetUserStakingStatsWithResponse call
func ParseGetUserStakingStatsResponse(rsp *http.Response) (*GetUserStakingStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserStakingStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserStakesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCollectStakingRewardResponse parses an HTTP response from a CollectStakingRewardWithResponse call
func ParseCollectStakingRewardResponse(rsp *http.Response) (*CollectStakingRewardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectStakingRewardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StakingCollectRewardTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStakeToStakingContractResponse parses an HTTP response from a StakeToStakingContractWithResponse call
func ParseStakeToStakingContractResponse(rsp *http.Response) (*StakeToStakingContractResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StakeToStakingContractResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StakingStakeTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWithdrawStakedAssetResponse parses an HTTP response from a WithdrawStakedAssetWithResponse call
func ParseWithdrawStakedAssetResponse(rsp *http.Response) (*WithdrawStakedAssetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WithdrawStakedAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StakingWithdrawTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectorDataResponse parses an HTTP response from a GetCollectorDataWithResponse call
func ParseGetCollectorDataResponse(rsp *http.Response) (*GetCollectorDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectorDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Stats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSwapQuoteResponse parses an HTTP response from a GetSwapQuoteWithResponse call
func ParseGetSwapQuoteResponse(rsp *http.Response) (*GetSwapQuoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSwapQuoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuoteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVaultsByOwnerResponse parses an HTTP response from a GetVaultsByOwnerWithResponse call
func ParseGetVaultsByOwnerResponse(rsp *http.Response) (*GetVaultsByOwnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVaultsByOwnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VaultsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVaultByIdResponse parses an HTTP response from a GetVaultByIdWithResponse call
func ParseGetVaultByIdResponse(rsp *http.Response) (*GetVaultByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVaultByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Vault
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVaultEventsByIdResponse parses an HTTP response from a GetVaultEventsByIdWithResponse call
func ParseGetVaultEventsByIdResponse(rsp *http.Response) (*GetVaultEventsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVaultEventsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VaultEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUnfilledOrdersWebsocketResponse parses an HTTP response from a GetUnfilledOrdersWebsocketWithResponse call
func ParseGetUnfilledOrdersWebsocketResponse(rsp *http.Response) (*GetUnfilledOrdersWebsocketResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUnfilledOrdersWebsocketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
