// Package service provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package service

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for ChainActivityStepType.
const (
	ChainActivityStepTypeEIP712SignRequest   ChainActivityStepType = "EIP712SignRequest"
	ChainActivityStepTypePersonalSignRequest ChainActivityStepType = "PersonalSignRequest"
	ChainActivityStepTypePreparedTx          ChainActivityStepType = "PreparedTx"
)

// Defines values for EventDomain.
const (
	Chainlink        EventDomain = "chainlink"
	Lendingpool      EventDomain = "lendingpool"
	StableCoinSystem EventDomain = "stableCoinSystem"
	UniswapV3        EventDomain = "uniswapV3"
)

// Defines values for EventName.
const (
	EventNameFile                       EventName = "File"
	EventNameLendingpoolBorrow          EventName = "LendingpoolBorrow"
	EventNameLendingpoolLiquidationCall EventName = "LendingpoolLiquidationCall"
	EventNameLendingpoolRepay           EventName = "LendingpoolRepay"
	EventNameLendingpoolWithdraw        EventName = "LendingpoolWithdraw"
	EventNameMedian                     EventName = "Median"
	EventNamePermission                 EventName = "Permission"
	EventNameUnknown                    EventName = "Unknown"
	EventNameVaultsDeposit              EventName = "VaultsDeposit"
	EventNameVaultsKick                 EventName = "VaultsKick"
	EventNameVaultsMint                 EventName = "VaultsMint"
	EventNameVaultsRedo                 EventName = "VaultsRedo"
	EventNameVaultsRepay                EventName = "VaultsRepay"
	EventNameVaultsTake                 EventName = "VaultsTake"
	EventNameVaultsWithdraw             EventName = "VaultsWithdraw"
	EventNameVaultsYank                 EventName = "VaultsYank"
)

// Defines values for EventType.
const (
	Executive EventType = "executive"
	Oracle    EventType = "oracle"
	User      EventType = "user"
)

// Defines values for OrderOrderStatus.
const (
	OrderOrderStatusCancelled         OrderOrderStatus = "cancelled"
	OrderOrderStatusError             OrderOrderStatus = "error"
	OrderOrderStatusExpired           OrderOrderStatus = "expired"
	OrderOrderStatusFilled            OrderOrderStatus = "filled"
	OrderOrderStatusInsufficientFunds OrderOrderStatus = "insufficient-funds"
	OrderOrderStatusOpen              OrderOrderStatus = "open"
)

// Defines values for OrderOrderType.
const (
	OrderOrderTypeDutch OrderOrderType = "dutch"
	OrderOrderTypeLimit OrderOrderType = "limit"
)

// Defines values for OrderType.
const (
	Classic    OrderType = "Classic"
	DutchLimit OrderType = "DutchLimit"
)

// Defines values for Symbol.
const (
	DAI  Symbol = "DAI"
	ETH  Symbol = "ETH"
	TMN  Symbol = "TMN"
	USD  Symbol = "USD"
	USDC Symbol = "USDC"
	USDT Symbol = "USDT"
	WBTC Symbol = "WBTC"
	WETH Symbol = "WETH"
	ZAR  Symbol = "ZAR"
)

// Defines values for TradeType.
const (
	ExactInput  TradeType = "ExactInput"
	ExactOutput TradeType = "ExactOutput"
)

// Defines values for GetUnfilledOrdersParamsType.
const (
	GetUnfilledOrdersParamsTypeDutch GetUnfilledOrdersParamsType = "dutch"
	GetUnfilledOrdersParamsTypeLimit GetUnfilledOrdersParamsType = "limit"
)

// Defines values for GetUnfilledOrdersParamsStatus.
const (
	GetUnfilledOrdersParamsStatusCancelled         GetUnfilledOrdersParamsStatus = "cancelled"
	GetUnfilledOrdersParamsStatusError             GetUnfilledOrdersParamsStatus = "error"
	GetUnfilledOrdersParamsStatusExpired           GetUnfilledOrdersParamsStatus = "expired"
	GetUnfilledOrdersParamsStatusFilled            GetUnfilledOrdersParamsStatus = "filled"
	GetUnfilledOrdersParamsStatusInsufficientFunds GetUnfilledOrdersParamsStatus = "insufficient-funds"
	GetUnfilledOrdersParamsStatusOpen              GetUnfilledOrdersParamsStatus = "open"
)

// Defines values for GetVaultEventsByIdParamsType.
const (
	Deposit  GetVaultEventsByIdParamsType = "deposit"
	Mint     GetVaultEventsByIdParamsType = "mint"
	Repay    GetVaultEventsByIdParamsType = "repay"
	Withdraw GetVaultEventsByIdParamsType = "withdraw"
)

// Account defines model for Account.
type Account struct {
	// Address Ethereum address of the account
	Address            string                    `json:"address"`
	LendingpoolSummary AccountLendingpoolSummary `json:"lendingpoolSummary"`
	NetWorth           Currency                  `json:"netWorth"`

	// Points The number of points the account has.
	Points                  int64                          `json:"points"`
	StabelcoinSystemSummary AccountStablecoinSystemSummary `json:"stabelcoinSystemSummary"`
	StakingSummary          AccountStakingSummary          `json:"stakingSummary"`
	TotalDebt               Currency                       `json:"totalDebt"`
	TotalDeposits           Currency                       `json:"totalDeposits"`
	WalletBalance           WalletBalance                  `json:"walletBalance"`
}

// AccountLendingpoolSummary defines model for AccountLendingpoolSummary.
type AccountLendingpoolSummary struct {
	AvailableToBorrow Currency `json:"availableToBorrow"`

	// BorrowPowerUsed Borrow power used in lending pool
	BorrowPowerUsed string `json:"borrowPowerUsed"`

	// CurrentLiquidationThreshold Current liquidation threshold in lending pool
	CurrentLiquidationThreshold string `json:"currentLiquidationThreshold"`

	// HealthFactor Health factor in lending pool
	HealthFactor string `json:"healthFactor"`

	// LoanToValue Loan to value in lending pool
	LoanToValue string `json:"loanToValue"`

	// NetApy Net annual percentage yield in lending pool
	NetApy string `json:"netApy"`

	// TotalBorrowApy Total borrow rate in lending pool for account
	TotalBorrowApy  string   `json:"totalBorrowApy"`
	TotalCollateral Currency `json:"totalCollateral"`
	TotalDebt       Currency `json:"totalDebt"`
	TotalDeposits   Currency `json:"totalDeposits"`

	// TotalSupplyApy Total supply rate in lending pool for account
	TotalSupplyApy string `json:"totalSupplyApy"`
}

// AccountStablecoinSystemSummary defines model for AccountStablecoinSystemSummary.
type AccountStablecoinSystemSummary struct {
	// NetApy Net annual percentage yield in stablecoin system
	NetApy        string   `json:"netApy"`
	TotalDebt     Currency `json:"totalDebt"`
	TotalDeposits Currency `json:"totalDeposits"`
}

// AccountStakingSummary defines model for AccountStakingSummary.
type AccountStakingSummary struct {
	// NetApy Net annual percentage yield in staking contract
	NetApy          string   `json:"netApy"`
	TotalStake      Currency `json:"totalStake"`
	UnclaimedReward Currency `json:"unclaimedReward"`
}

// Address defines model for Address.
type Address struct {
	// Address The Ethereum address.
	Address string `json:"address"`

	// Label The label of the address.
	Label string `json:"label"`
}

// AddressResponse defines model for AddressResponse.
type AddressResponse struct {
	Data []Address `json:"data"`
}

// Balance defines model for Balance.
type Balance struct {
	Balance Currency `json:"balance"`
	Token   Token    `json:"token"`
}

// ChainActivity defines model for ChainActivity.
type ChainActivity struct {
	NumberOfSteps int                 `json:"numberOfSteps"`
	StepNumber    int                 `json:"stepNumber"`
	Steps         []ChainActivityStep `json:"steps"`
}

// ChainActivityStep defines model for ChainActivityStep.
type ChainActivityStep struct {
	Data ChainActivityStepData `json:"data"`
	Type ChainActivityStepType `json:"type"`
}

// ChainActivityStepType defines model for ChainActivityStep.Type.
type ChainActivityStepType string

// ChainActivityStepData defines model for ChainActivityStepData.
type ChainActivityStepData struct {
	union json.RawMessage
}

// Currency defines model for Currency.
type Currency map[string]string

// DutchAmount defines model for DutchAmount.
type DutchAmount struct {
	EndAmount   Currency `json:"endAmount"`
	Recipient   *string  `json:"recipient,omitempty"`
	StartAmount Currency `json:"startAmount"`
	Token       Token    `json:"token"`
}

// EIP712SignRequest defines model for EIP712SignRequest.
type EIP712SignRequest struct {
	// Hash The hash of the EIP712 signature that needs to be signed
	Hash string `json:"hash"`

	// Name The name of the EIP712 signature
	Name      string    `json:"name"`
	TypedData TypedData `json:"typedData"`
}

// Error defines model for Error.
type Error struct {
	// Msg Error message
	Msg     string   `json:"msg"`
	Reasons []string `json:"reasons"`
}

// ErrorMessage defines model for ErrorMessage.
type ErrorMessage struct {
	Solutions []ErrorSolution `json:"solutions"`

	// UserMessage User-friendly error message
	UserMessage string `json:"userMessage"`
}

// ErrorReason Error reasons
type ErrorReason = string

// ErrorSolution Possible solutions for the error
type ErrorSolution = string

// EventDetailsResponse defines model for EventDetailsResponse.
type EventDetailsResponse struct {
	Data []Log `json:"data"`
}

// EventDomain The domain of the event.
type EventDomain string

// EventName defines model for EventName.
type EventName string

// EventType The type of the event. who has triggered the event.
type EventType string

// ExtendedEvent defines model for ExtendedEvent.
type ExtendedEvent struct {
	// Domain The domain of the event.
	Domain EventDomain `json:"domain"`

	// Id Identifier for the event.
	Id   int       `json:"id"`
	Name EventName `json:"name"`

	// Payload The payload of the event. The payload is a JSON-marshalled
	Payload map[string]interface{} `json:"payload"`
	Raw     Log                    `json:"raw"`

	// Type The type of the event. who has triggered the event.
	Type EventType `json:"type"`
}

// FormattedReserveData defines model for FormattedReserveData.
type FormattedReserveData struct {
	AvailableLiquidity  Currency `json:"availableLiquidity"`
	BaseLTVasCollateral string   `json:"baseLTVasCollateral"`
	BorrowingEnabled    bool     `json:"borrowingEnabled"`

	// Id Identifier for the reserve data.
	Id                          string   `json:"id"`
	IsActive                    bool     `json:"isActive"`
	IsFrozen                    bool     `json:"isFrozen"`
	Price                       Currency `json:"price"`
	ReserveFactor               string   `json:"reserveFactor"`
	ReserveLiquidationBonus     string   `json:"reserveLiquidationBonus"`
	ReserveLiquidationThreshold string   `json:"reserveLiquidationThreshold"`
	SupplyAPR                   string   `json:"supplyAPR"`
	SupplyAPY                   string   `json:"supplyAPY"`
	TotalDebt                   Currency `json:"totalDebt"`
	TotalLiquidity              Currency `json:"totalLiquidity"`
	UnderlyingAsset             Token    `json:"underlyingAsset"`
	UsageAsCollateralEnabled    bool     `json:"usageAsCollateralEnabled"`
	UtilizationRate             string   `json:"utilizationRate"`
	VariableBorrowAPR           string   `json:"variableBorrowAPR"`
	VariableBorrowAPY           string   `json:"variableBorrowAPY"`

	// VariableDebtTokenAddress Address of the associated variable debt token contract in hexadecimal format.
	VariableDebtTokenAddress string `json:"variableDebtTokenAddress"`

	// ZTokenAddress Address of the associated zToken contract in hexadecimal format.
	ZTokenAddress string `json:"zTokenAddress"`
}

// Ilk defines model for Ilk.
type Ilk struct {
	// AnnualStabilityFee Annual Stability Fee
	AnnualStabilityFee string   `json:"annualStabilityFee"`
	AvailableToBorrow  Currency `json:"availableToBorrow"`

	// Clipper Clipper Address
	Clipper     string   `json:"clipper"`
	Debt        Currency `json:"debt"`
	DebtCeiling Currency `json:"debtCeiling"`
	Dirt        Currency `json:"dirt"`
	DustLimit   Currency `json:"dustLimit"`

	// Gem Gem Address
	Gem  string   `json:"gem"`
	Hole Currency `json:"hole"`

	// Join Join Address
	Join string `json:"join"`

	// LiquidationPenalty Liquidation Penalty
	LiquidationPenalty string `json:"liquidationPenalty"`

	// MaximumLoanToValue Maximum Loan To Value
	MaximumLoanToValue string `json:"maximumLoanToValue"`

	// Median Median Address
	Median string `json:"median"`

	// MinimumCollateralizationRatio Minimum Collateralization Ratio
	MinimumCollateralizationRatio string `json:"minimumCollateralizationRatio"`

	// Name Name of the ILK
	Name      string   `json:"name"`
	NextPrice Currency `json:"nextPrice"`

	// Pip Pip Address
	Pip   string   `json:"pip"`
	Price Currency `json:"price"`

	// Symbol Symbol representation
	Symbol Symbol `json:"symbol"`
}

// IlksResponse defines model for IlksResponse.
type IlksResponse struct {
	Data []Ilk `json:"data"`
}

// LendingpoolBorrow defines model for LendingpoolBorrow.
type LendingpoolBorrow struct {
	Amount Currency `json:"amount"`

	// BorrowRate The borrow rate.
	BorrowRate      string   `json:"borrowRate"`
	MaxBorrowAmount Currency `json:"maxBorrowAmount"`
	UnderlyingAsset Token    `json:"underlyingAsset"`

	// User The Ethereum address of the user.
	User string `json:"user"`
}

// LendingpoolBorrowTxRequest defines model for LendingpoolBorrowTxRequest.
type LendingpoolBorrowTxRequest struct {
	// Amount The amount to borrow in native token units
	Amount *string `json:"amount,omitempty"`
	Symbol string  `json:"symbol"`

	// User Ethereum address of the user
	User string `json:"user"`
}

// LendingpoolBorrowTxResponse defines model for LendingpoolBorrowTxResponse.
type LendingpoolBorrowTxResponse struct {
	ChainActivity *ChainActivity         `json:"chainActivity,omitempty"`
	Response      *LendingpoolTxResponse `json:"response,omitempty"`
}

// LendingpoolDeposit defines model for LendingpoolDeposit.
type LendingpoolDeposit struct {
	Amount Currency `json:"amount"`

	// SupplyAPY The supply APY.
	SupplyAPY       string `json:"supplyAPY"`
	UnderlyingAsset Token  `json:"underlyingAsset"`

	// UsageAsCollateralEnabledOnUser Whether the user has enabled the asset as collateral.
	UsageAsCollateralEnabledOnUser bool `json:"usageAsCollateralEnabledOnUser"`

	// User The Ethereum address of the user.
	User string `json:"user"`
}

// LendingpoolDepositTxRequest defines model for LendingpoolDepositTxRequest.
type LendingpoolDepositTxRequest struct {
	// Amount The amount to deposit in native token units, if not provided, it will be calculated based on the token balance
	Amount *string `json:"amount,omitempty"`
	Symbol string  `json:"symbol"`

	// User Ethereum address of the user
	User string `json:"user"`
}

// LendingpoolDepositTxResponse defines model for LendingpoolDepositTxResponse.
type LendingpoolDepositTxResponse struct {
	ChainActivity *ChainActivity         `json:"chainActivity,omitempty"`
	Response      *LendingpoolTxResponse `json:"response,omitempty"`
}

// LendingpoolRepayTxRequest defines model for LendingpoolRepayTxRequest.
type LendingpoolRepayTxRequest struct {
	// Amount The amount to repay in native token units, if not provided, it will be calculated based on the borrow balance
	Amount *string `json:"amount,omitempty"`
	Symbol string  `json:"symbol"`

	// User Ethereum address of the user
	User string `json:"user"`
}

// LendingpoolRepayTxResponse defines model for LendingpoolRepayTxResponse.
type LendingpoolRepayTxResponse struct {
	ChainActivity *ChainActivity         `json:"chainActivity,omitempty"`
	Response      *LendingpoolTxResponse `json:"response,omitempty"`
}

// LendingpoolStats defines model for LendingpoolStats.
type LendingpoolStats struct {
	TotalAvailable  map[string]string `json:"totalAvailable"`
	TotalBorrows    map[string]string `json:"totalBorrows"`
	TotalMarketSize map[string]string `json:"totalMarketSize"`
}

// LendingpoolTxResponse defines model for LendingpoolTxResponse.
type LendingpoolTxResponse struct {
	// NextHealthFactor The health factor after the deposit
	NextHealthFactor *string `json:"nextHealthFactor,omitempty"`
}

// LendingpoolUseAssetAsCollateralTxRequest defines model for LendingpoolUseAssetAsCollateralTxRequest.
type LendingpoolUseAssetAsCollateralTxRequest struct {
	// Enabled Enable or disable the asset as collateral
	Enabled bool `json:"enabled"`

	// Symbol Symbol of asset
	Symbol string `json:"symbol"`

	// User Ethereum address of the user
	User string `json:"user"`
}

// LendingpoolUseAssetAsCollateralTxResponse defines model for LendingpoolUseAssetAsCollateralTxResponse.
type LendingpoolUseAssetAsCollateralTxResponse struct {
	ChainActivity *ChainActivity         `json:"chainActivity,omitempty"`
	Response      *LendingpoolTxResponse `json:"response,omitempty"`
}

// LendingpoolWithdrawTxRequest defines model for LendingpoolWithdrawTxRequest.
type LendingpoolWithdrawTxRequest struct {
	// Amount The amount to withdraw in native token units, if not provided, it will be calculated based on the deposit balance
	Amount *string `json:"amount,omitempty"`
	Symbol string  `json:"symbol"`

	// User Ethereum address of the user
	User string `json:"user"`
}

// LendingpoolWithdrawTxResponse defines model for LendingpoolWithdrawTxResponse.
type LendingpoolWithdrawTxResponse struct {
	ChainActivity *ChainActivity         `json:"chainActivity,omitempty"`
	Response      *LendingpoolTxResponse `json:"response,omitempty"`
}

// Log defines model for Log.
type Log struct {
	// Address The Ethereum address
	Address string `json:"address"`

	// BlockHash The block hash
	BlockHash string `json:"blockHash"`

	// BlockNumber The block number
	BlockNumber uint64 `json:"blockNumber"`

	// Contract The contract address
	Contract string `json:"contract"`

	// Data The data of the log
	Data string `json:"data"`

	// Decoded The decoded log, if available
	Decoded *map[string]string `json:"decoded,omitempty"`

	// Index The index
	Index uint `json:"index"`

	// Name The name of the log
	Name      string    `json:"name"`
	Timestamp Timestamp `json:"timestamp"`
	Topics    []string  `json:"topics"`

	// TxHash The transaction hash
	TxHash string `json:"txHash"`
}

// MethodParameters defines model for MethodParameters.
type MethodParameters struct {
	Calldata string `json:"calldata"`
	To       string `json:"to"`
	Value    string `json:"value"`
}

// Order defines model for Order.
type Order struct {
	ChainId      int64            `json:"chainId"`
	EncodedOrder string           `json:"encodedOrder"`
	Input        RawDutchAmount   `json:"input"`
	OrderHash    string           `json:"orderHash"`
	OrderStatus  OrderOrderStatus `json:"orderStatus"`
	OrderType    OrderOrderType   `json:"orderType"`
	Outputs      []RawDutchAmount `json:"outputs"`
	QuoteId      *string          `json:"quoteId,omitempty"`
	Signature    string           `json:"signature"`
}

// OrderOrderStatus defines model for Order.OrderStatus.
type OrderOrderStatus string

// OrderOrderType defines model for Order.OrderType.
type OrderOrderType string

// OrderInfo defines model for OrderInfo.
type OrderInfo struct {
	AdditionalValidationContract string        `json:"additionalValidationContract"`
	AdditionalValidationData     string        `json:"additionalValidationData"`
	ChainId                      int           `json:"chainId"`
	Deadline                     Timestamp     `json:"deadline"`
	DecayEndTime                 Timestamp     `json:"decayEndTime"`
	DecayStartTime               Timestamp     `json:"decayStartTime"`
	ExclusiveFiller              string        `json:"exclusiveFiller"`
	ExclusivityOverrideBps       int           `json:"exclusivityOverrideBps"`
	Input                        DutchAmount   `json:"input"`
	Nonce                        string        `json:"nonce"`
	Outputs                      []DutchAmount `json:"outputs"`
	Permit2Address               string        `json:"permit2Address"`
	Reactor                      string        `json:"reactor"`
	Swapper                      string        `json:"swapper"`
}

// OrderResponse defines model for OrderResponse.
type OrderResponse struct {
	Data []Order `json:"data"`
}

// OrderType defines model for OrderType.
type OrderType string

// PermitSingle defines model for PermitSingle.
type PermitSingle struct {
	// Hash The hash of the permit that needs to be signed
	Hash      string    `json:"hash"`
	TypedData TypedData `json:"typedData"`
}

// PersonalSignRequest defines model for PersonalSignRequest.
type PersonalSignRequest struct {
	// Message The message that needs to be signed
	Message string `json:"message"`
}

// PreparedTx defines model for PreparedTx.
type PreparedTx struct {
	GasFeeEstimate   Currency          `json:"gasFeeEstimate"`
	GasUseEstimate   int               `json:"gasUseEstimate"`
	Label            map[string]string `json:"label"`
	MethodParameters MethodParameters  `json:"methodParameters"`
	Type             string            `json:"type"`
}

// Price defines model for Price.
type Price struct {
	// Symbol Symbol representation
	Symbol    Symbol    `json:"symbol"`
	Timestamp Timestamp `json:"timestamp"`
	Value     Currency  `json:"value"`
}

// PriceListResponse defines model for PriceListResponse.
type PriceListResponse struct {
	Data []Price `json:"data"`
}

// QuoteRequest defines model for QuoteRequest.
type QuoteRequest struct {
	Amount      string               `json:"amount"`
	InputToken  string               `json:"inputToken"`
	Options     *QuoteRequestOptions `json:"options,omitempty"`
	OutputToken string               `json:"outputToken"`
	Recipient   string               `json:"recipient"`
	RequestId   *string              `json:"requestId,omitempty"`
	TradeType   TradeType            `json:"tradeType"`
	Type        *OrderType           `json:"type,omitempty"`
}

// QuoteRequestOptions defines model for QuoteRequestOptions.
type QuoteRequestOptions struct {
	DryRun             *bool   `json:"dryRun,omitempty"`
	EncodedOrder       *string `json:"encodedOrder,omitempty"`
	PermitAmount       *string `json:"permitAmount,omitempty"`
	PermitExpiration   *int    `json:"permitExpiration,omitempty"`
	PermitNonce        *string `json:"permitNonce,omitempty"`
	PermitSigDeadline  *int    `json:"permitSigDeadline,omitempty"`
	PermitSignature    *string `json:"permitSignature,omitempty"`
	QuoteId            *string `json:"quoteId,omitempty"`
	SlippageTolerance  *string `json:"slippageTolerance,omitempty"`
	UseSyntheticQuotes *bool   `json:"useSyntheticQuotes,omitempty"`
}

// QuoteResponse defines model for QuoteResponse.
type QuoteResponse struct {
	Amount           Currency          `json:"amount"`
	EncodedOrder     *string           `json:"encodedOrder,omitempty"`
	GasFeeEstimate   Currency          `json:"gasFeeEstimate"`
	GasPrice         Currency          `json:"gasPrice"`
	GasUseEstimate   int               `json:"gasUseEstimate"`
	MethodParameters *MethodParameters `json:"methodParameters,omitempty"`
	OrderHash        *string           `json:"orderHash,omitempty"`
	OrderInfo        *OrderInfo        `json:"orderInfo,omitempty"`
	PermitData       *TypedData        `json:"permitData,omitempty"`
	Quote            Currency          `json:"quote"`
	QuoteId          string            `json:"quoteId"`
	Route            []RouteItem       `json:"route"`
	RouteString      string            `json:"routeString"`
	Time             Timestamp         `json:"time"`
	TradeType        TradeType         `json:"tradeType"`
	Type             OrderType         `json:"type"`
}

// RawDutchAmount defines model for RawDutchAmount.
type RawDutchAmount struct {
	EndAmount   string  `json:"endAmount"`
	Recipient   *string `json:"recipient,omitempty"`
	StartAmount string  `json:"startAmount"`
	Token       string  `json:"token"`
}

// RouteItem defines model for RouteItem.
type RouteItem = V3PoolInRoute

// Scoreboard defines model for Scoreboard.
type Scoreboard struct {
	Items []ScoreboardItem `json:"items"`
}

// ScoreboardItem defines model for ScoreboardItem.
type ScoreboardItem struct {
	Address string `json:"address"`
	Points  int64  `json:"points"`
}

// StablecoinSystemBarkTxRequest defines model for StablecoinSystemBarkTxRequest.
type StablecoinSystemBarkTxRequest struct {
	// User Ethereum address of the user who is liquidating the vault and receiving incentives.
	User string `json:"user"`

	// VaultId The ID of the vault
	VaultId int `json:"vaultId"`
}

// StablecoinSystemCreateVaultTxRequest defines model for StablecoinSystemCreateVaultTxRequest.
type StablecoinSystemCreateVaultTxRequest struct {
	// CollateralAmount The amount of collateral to deposit in native token units
	CollateralAmount *string `json:"collateralAmount,omitempty"`

	// IlkName The name of the ilk
	IlkName string `json:"ilkName"`

	// MintAmount The amount of stablecoin to mint in native token units
	MintAmount string `json:"mintAmount"`

	// User Ethereum address of the user
	User string `json:"user"`
}

// StablecoinSystemDepositCollateralTxRequest defines model for StablecoinSystemDepositCollateralTxRequest.
type StablecoinSystemDepositCollateralTxRequest struct {
	// Amount The amount of collateral to deposit in native token units, if not provided, it will be calculated based on the wallet balance
	Amount *string `json:"amount,omitempty"`

	// User Ethereum address of the user
	User string `json:"user"`

	// VaultId The ID of the vault
	VaultId int `json:"vaultId"`
}

// StablecoinSystemGemexitTxRequest defines model for StablecoinSystemGemexitTxRequest.
type StablecoinSystemGemexitTxRequest struct {
	// Amount The amount of Gem token to exit from Vat contract
	Amount string `json:"amount"`

	// Ilk Name of the ILK
	Ilk string `json:"ilk"`

	// User Ethereum address of the user intends to exit gem tokens from the Vat contract and receive them..
	User string `json:"user"`
}

// StablecoinSystemMintZarTxRequest defines model for StablecoinSystemMintZarTxRequest.
type StablecoinSystemMintZarTxRequest struct {
	// Amount The amount of stablecoin to mint in native token units, if not provided, it will be calculated based on the available to mint amount
	Amount *string `json:"amount,omitempty"`

	// User Ethereum address of the user
	User string `json:"user"`

	// VaultId The ID of the vault
	VaultId int `json:"vaultId"`
}

// StablecoinSystemRedoTxRequest defines model for StablecoinSystemRedoTxRequest.
type StablecoinSystemRedoTxRequest struct {
	// AuctionId The ID of the auction
	AuctionId int `json:"auctionId"`

	// Ilk Name of the ILK
	Ilk string `json:"ilk"`

	// User Ethereum address of the user resetting the auction and receiving incentives.
	User string `json:"user"`
}

// StablecoinSystemRepayZarTxRequest defines model for StablecoinSystemRepayZarTxRequest.
type StablecoinSystemRepayZarTxRequest struct {
	// Amount The amount of stablecoin to repay in native token units, if not provided, it will be calculated based on the borrow balance
	Amount *string `json:"amount,omitempty"`

	// User Ethereum address of the user
	User string `json:"user"`

	// VaultId The ID of the vault
	VaultId int `json:"vaultId"`
}

// StablecoinSystemStats defines model for StablecoinSystemStats.
type StablecoinSystemStats struct {
	// SystemBadDebt System bad debt
	SystemBadDebt SystemBadDebt `json:"systemBadDebt"`

	// SystemDebt System debt
	SystemDebt SystemDebt `json:"systemDebt"`

	// SystemDebtCeiling System debt ceiling
	SystemDebtCeiling SystemDebtCeiling `json:"systemDebtCeiling"`

	// SystemSurplus System surplus
	SystemSurplus SystemSurplus `json:"systemSurplus"`

	// SystemSurplusBuffer System surplus buffer
	SystemSurplusBuffer SystemSurplusBuffer `json:"systemSurplusBuffer"`

	// SystemSurplusLotSize System surplus lot size
	SystemSurplusLotSize SystemSurplusLotSize `json:"systemSurplusLotSize"`
}

// StablecoinSystemTakeTxRequest defines model for StablecoinSystemTakeTxRequest.
type StablecoinSystemTakeTxRequest struct {
	// AuctionId The ID of the auction
	AuctionId int `json:"auctionId"`

	// CollateralAmountUpperLimit upper limit on the amount of collateral to buy [wad]
	CollateralAmountUpperLimit string `json:"collateralAmountUpperLimit"`

	// Ilk Name of the ILK
	Ilk string `json:"ilk"`

	// MaxAcceptablePrice Maximum acceptable price (ZAR / collateral) [ray]
	MaxAcceptablePrice string `json:"maxAcceptablePrice"`

	// User Ethereum address of the user taking the auction.
	User string `json:"user"`
}

// StablecoinSystemWithdrawCollateralTxRequest defines model for StablecoinSystemWithdrawCollateralTxRequest.
type StablecoinSystemWithdrawCollateralTxRequest struct {
	// Amount The amount of collateral to withdraw in native token units, if not provided, it will be calculated based on the withdrawable balance
	Amount *string `json:"amount,omitempty"`

	// User Ethereum address of the user
	User string `json:"user"`

	// VaultId The ID of the vault
	VaultId int `json:"vaultId"`
}

// StablecoinSystemZarexitTxRequest defines model for StablecoinSystemZarexitTxRequest.
type StablecoinSystemZarexitTxRequest struct {
	// Amount The amount of Zar token to exit from Vat contract
	Amount string `json:"amount"`

	// User Ethereum address of the user intends to exit zar tokens from the Vat contract and receive them..
	User string `json:"user"`
}

// StablecoinSystemZarjoinTxRequest defines model for StablecoinSystemZarjoinTxRequest.
type StablecoinSystemZarjoinTxRequest struct {
	// Amount The amount of ZAR to approve and join into Vat contract
	Amount string `json:"amount"`

	// User Ethereum address of the user intends to join zar tokens into the Vat contract.
	User string `json:"user"`
}

// StakeBalance defines model for StakeBalance.
type StakeBalance = Currency

// StakePlan defines model for StakePlan.
type StakePlan struct {
	// Apy Annual percentage yield of the staking plan
	Apy string `json:"apy"`

	// ContractAddress Ethereum address of the staking contract
	ContractAddress string    `json:"contractAddress"`
	FinishAt        Timestamp `json:"finishAt"`

	// PlanName Name of staking plan
	PlanName    string `json:"planName"`
	RewardToken Token  `json:"rewardToken"`
	StakeToken  Token  `json:"stakeToken"`
}

// StakePlansResponse defines model for StakePlansResponse.
type StakePlansResponse struct {
	Data []StakePlan `json:"data"`
}

// StakingCollectRewardTxRequest defines model for StakingCollectRewardTxRequest.
type StakingCollectRewardTxRequest struct {
	// ContractAddress Ethereum address of the staking contract
	ContractAddress string `json:"contractAddress"`

	// User Ethereum address of the user
	User string `json:"user"`
}

// StakingCollectRewardTxResponse defines model for StakingCollectRewardTxResponse.
type StakingCollectRewardTxResponse struct {
	ChainActivity *ChainActivity `json:"chainActivity,omitempty"`
}

// StakingStakeTxRequest defines model for StakingStakeTxRequest.
type StakingStakeTxRequest struct {
	// Amount The amount of asset to stake in native token units
	Amount *string `json:"amount,omitempty"`

	// ContractAddress Ethereum address of the staking contract
	ContractAddress string `json:"contractAddress"`

	// User Ethereum address of the user
	User string `json:"user"`
}

// StakingStakeTxResponse defines model for StakingStakeTxResponse.
type StakingStakeTxResponse struct {
	ChainActivity *ChainActivity `json:"chainActivity,omitempty"`
}

// StakingWithdrawTxRequest defines model for StakingWithdrawTxRequest.
type StakingWithdrawTxRequest struct {
	// Amount The amount of asset to withdraw in native token units
	Amount *string `json:"amount,omitempty"`

	// ContractAddress Ethereum address of the staking contract
	ContractAddress string `json:"contractAddress"`

	// User Ethereum address of the user
	User string `json:"user"`
}

// StakingWithdrawTxResponse defines model for StakingWithdrawTxResponse.
type StakingWithdrawTxResponse struct {
	ChainActivity *ChainActivity `json:"chainActivity,omitempty"`
}

// Stats defines model for Stats.
type Stats struct {
	Lendingpool      LendingpoolStats      `json:"lendingpool"`
	StablecoinSystem StablecoinSystemStats `json:"stablecoinSystem"`
}

// Symbol Symbol representation
type Symbol string

// SystemBadDebt defines model for SystemBadDebt.
type SystemBadDebt = Currency

// SystemDebt defines model for SystemDebt.
type SystemDebt = Currency

// SystemDebtCeiling defines model for SystemDebtCeiling.
type SystemDebtCeiling = Currency

// SystemSurplus defines model for SystemSurplus.
type SystemSurplus = Currency

// SystemSurplusBuffer defines model for SystemSurplusBuffer.
type SystemSurplusBuffer = Currency

// SystemSurplusLotSize defines model for SystemSurplusLotSize.
type SystemSurplusLotSize = Currency

// TimeRange defines model for TimeRange.
type TimeRange struct {
	From *time.Time `json:"from,omitempty"`
	To   *time.Time `json:"to,omitempty"`
}

// Timestamp defines model for Timestamp.
type Timestamp struct {
	// Gregorian Gregorian date
	Gregorian string `json:"gregorian"`

	// Jalaali Jalaali date
	Jalaali string `json:"jalaali"`
}

// Token defines model for Token.
type Token struct {
	// Address The Ethereum address of the token.
	Address string `json:"address"`

	// ChainId The chain ID of the token.
	ChainId int64 `json:"chainId"`

	// Decimals The number of decimals for the token.
	Decimals int64 `json:"decimals"`

	// LogoUri The URI of the token's logo.
	LogoUri string `json:"logoUri"`

	// Name The name of the token.
	Name string `json:"name"`

	// PersianName The Persian name of the token.
	PersianName string `json:"persianName"`

	// Symbol Symbol representation
	Symbol Symbol `json:"symbol"`
}

// TradeType defines model for TradeType.
type TradeType string

// Type defines model for Type.
type Type struct {
	Name string `json:"name"`
	Type string `json:"type"`
}

// TypedData defines model for TypedData.
type TypedData struct {
	Domain      TypedDataDomain        `json:"domain"`
	Message     map[string]interface{} `json:"message"`
	PrimaryType string                 `json:"primaryType"`

	// Types A map where each key is a string and each value is a list of Type
	Types Types `json:"types"`
}

// TypedDataDomain defines model for TypedDataDomain.
type TypedDataDomain struct {
	ChainId           string  `json:"chainId"`
	Name              string  `json:"name"`
	Salt              *string `json:"salt,omitempty"`
	VerifyingContract string  `json:"verifyingContract"`
	Version           *string `json:"version,omitempty"`
}

// Types A map where each key is a string and each value is a list of Type
type Types map[string][]Type

// UnclaimedReward defines model for UnclaimedReward.
type UnclaimedReward = Currency

// UpdateOrderRequest defines model for UpdateOrderRequest.
type UpdateOrderRequest struct {
	OrderHash string `json:"orderHash"`
}

// UserBorrowsResponse defines model for UserBorrowsResponse.
type UserBorrowsResponse struct {
	Data []LendingpoolBorrow `json:"data"`
}

// UserDepositsResponse defines model for UserDepositsResponse.
type UserDepositsResponse struct {
	Data []LendingpoolDeposit `json:"data"`
}

// UserError defines model for UserError.
type UserError struct {
	// Messages Localized error messages
	Messages map[string]ErrorMessage `json:"messages"`
	Reasons  []ErrorReason           `json:"reasons"`
}

// UserStake defines model for UserStake.
type UserStake struct {
	// Balance The amount of asset staked in native token units
	Balance StakeBalance `json:"balance"`

	// ContractAddress Ethereum address of the staking contract
	ContractAddress string `json:"contractAddress"`

	// PlanName Name of staking plan
	PlanName string `json:"planName"`

	// UnclaimedReward The amount of unclaimed reward in native token units
	UnclaimedReward UnclaimedReward `json:"unclaimedReward"`

	// User Ethereum address of the user
	User string `json:"user"`
}

// UserStakesResponse defines model for UserStakesResponse.
type UserStakesResponse struct {
	Data []UserStake `json:"data"`
}

// V3PoolInRoute defines model for V3PoolInRoute.
type V3PoolInRoute struct {
	Address  string `json:"address"`
	Fee      string `json:"fee"`
	TokenIn  Token  `json:"tokenIn"`
	TokenOut Token  `json:"tokenOut"`
}

// Vault defines model for Vault.
type Vault struct {
	AvailableToMint     Currency `json:"availableToMint"`
	AvailableToWithdraw Currency `json:"availableToWithdraw"`
	CollateralLocked    Currency `json:"collateralLocked"`

	// CollateralizationRatio The collateralization ratio of the vault.
	CollateralizationRatio string   `json:"collateralizationRatio"`
	Debt                   Currency `json:"debt"`

	// Id Identifier for the vault.
	Id               int      `json:"id"`
	Ilk              Ilk      `json:"ilk"`
	LiquidationPrice Currency `json:"liquidationPrice"`

	// LoanToValue The loan to value of the vault.
	LoanToValue string `json:"loanToValue"`

	// Owner Ethereum address of the vault owner.
	Owner string `json:"owner"`

	// Urn Ethereum address of the vault urn.
	Urn string `json:"urn"`
}

// VaultEventsResponse defines model for VaultEventsResponse.
type VaultEventsResponse struct {
	Data []ExtendedEvent `json:"data"`
}

// VaultsResponse defines model for VaultsResponse.
type VaultsResponse struct {
	Data []Vault `json:"data"`
}

// WalletBalance defines model for WalletBalance.
type WalletBalance struct {
	Balances []Balance `json:"balances"`
}

// GetAllAddressesParams defines parameters for GetAllAddresses.
type GetAllAddressesParams struct {
	// Format The type of addresses to return
	Format *string `form:"format,omitempty" json:"format,omitempty"`
}

// GetUserBorrowsParams defines parameters for GetUserBorrows.
type GetUserBorrowsParams struct {
	// User Ethereum address of the user
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// Reserve Ethereum address of the reserve
	Reserve *string `form:"reserve,omitempty" json:"reserve,omitempty"`

	// Cursor Cursor for pagination
	Cursor *int `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Limit the number of deposits returned (default is 50)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetUserDepositsParams defines parameters for GetUserDeposits.
type GetUserDepositsParams struct {
	// User Ethereum address of the user
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// Reserve Ethereum address of the reserve
	Reserve *string `form:"reserve,omitempty" json:"reserve,omitempty"`

	// Cursor Cursor for pagination
	Cursor *int `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Limit the number of deposits returned (default is 50)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// FetchReserveDataByAssetParams defines parameters for FetchReserveDataByAsset.
type FetchReserveDataByAssetParams struct {
	// Asset The asset address in hexadecimal format.
	Asset *string `form:"asset,omitempty" json:"asset,omitempty"`
}

// GetUnfilledOrdersParams defines parameters for GetUnfilledOrders.
type GetUnfilledOrdersParams struct {
	// Type Type of the order
	Type *GetUnfilledOrdersParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Hash order hash
	Hash *string `form:"hash,omitempty" json:"hash,omitempty"`

	// Status Status of the order
	Status *GetUnfilledOrdersParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Offerer Ethereum address of the offerer
	Offerer *string `form:"offerer,omitempty" json:"offerer,omitempty"`

	// Filler Ethereum address of the filler
	Filler *string `form:"filler,omitempty" json:"filler,omitempty"`

	// DecayStartTime Decay start time
	DecayStartTime *TimeRange `form:"decayStartTime,omitempty" json:"decayStartTime,omitempty"`

	// DecayEndTime Decay end time
	DecayEndTime *TimeRange `form:"decayEndTime,omitempty" json:"decayEndTime,omitempty"`

	// Deadline Order deadline
	Deadline *TimeRange `form:"deadline,omitempty" json:"deadline,omitempty"`

	// Cursor Cursor for pagination
	Cursor *int `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Limit the number of orders returned (default is 10)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetUnfilledOrdersParamsType defines parameters for GetUnfilledOrders.
type GetUnfilledOrdersParamsType string

// GetUnfilledOrdersParamsStatus defines parameters for GetUnfilledOrders.
type GetUnfilledOrdersParamsStatus string

// GetSingleTokenPermitParams defines parameters for GetSingleTokenPermit.
type GetSingleTokenPermitParams struct {
	// Token Ethereum address of the token
	Token string `form:"token" json:"token"`

	// User Ethereum address of the user
	User string `form:"user" json:"user"`
}

// ListPricesParams defines parameters for ListPrices.
type ListPricesParams struct {
	// Symbol Symbol of the price
	Symbol *string `form:"symbol,omitempty" json:"symbol,omitempty"`
}

// GetUserStakingStatsParams defines parameters for GetUserStakingStats.
type GetUserStakingStatsParams struct {
	// User Ethereum address of the user
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// Address Ethereum address of the staking contract
	Address *string `form:"address,omitempty" json:"address,omitempty"`

	// Active Filter by active stakes
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// Cursor Cursor for pagination
	Cursor *int `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Limit the number of stakes returned (default is 50)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetVaultsByOwnerParams defines parameters for GetVaultsByOwner.
type GetVaultsByOwnerParams struct {
	// Owner Ethereum address of the owner
	Owner *string `form:"owner,omitempty" json:"owner,omitempty"`
}

// GetVaultEventsByIdParams defines parameters for GetVaultEventsById.
type GetVaultEventsByIdParams struct {
	// Type Event type
	Type *GetVaultEventsByIdParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// GetVaultEventsByIdParamsType defines parameters for GetVaultEventsById.
type GetVaultEventsByIdParamsType string

// CreateLendingPoolBorrowJSONRequestBody defines body for CreateLendingPoolBorrow for application/json ContentType.
type CreateLendingPoolBorrowJSONRequestBody = LendingpoolBorrowTxRequest

// CreateLendingPoolDepositJSONRequestBody defines body for CreateLendingPoolDeposit for application/json ContentType.
type CreateLendingPoolDepositJSONRequestBody = LendingpoolDepositTxRequest

// CreateLendingPoolRepayJSONRequestBody defines body for CreateLendingPoolRepay for application/json ContentType.
type CreateLendingPoolRepayJSONRequestBody = LendingpoolRepayTxRequest

// SetLendingPoolAssetCollateralJSONRequestBody defines body for SetLendingPoolAssetCollateral for application/json ContentType.
type SetLendingPoolAssetCollateralJSONRequestBody = LendingpoolUseAssetAsCollateralTxRequest

// CreateLendingPoolWithdrawJSONRequestBody defines body for CreateLendingPoolWithdraw for application/json ContentType.
type CreateLendingPoolWithdrawJSONRequestBody = LendingpoolWithdrawTxRequest

// SyncOrderJSONRequestBody defines body for SyncOrder for application/json ContentType.
type SyncOrderJSONRequestBody = UpdateOrderRequest

// ExitGemTransactionJSONRequestBody defines body for ExitGemTransaction for application/json ContentType.
type ExitGemTransactionJSONRequestBody = StablecoinSystemGemexitTxRequest

// ResetAuctionTransactionJSONRequestBody defines body for ResetAuctionTransaction for application/json ContentType.
type ResetAuctionTransactionJSONRequestBody = StablecoinSystemRedoTxRequest

// TakeAuctionTransactionJSONRequestBody defines body for TakeAuctionTransaction for application/json ContentType.
type TakeAuctionTransactionJSONRequestBody = StablecoinSystemTakeTxRequest

// ExitZarTransactionJSONRequestBody defines body for ExitZarTransaction for application/json ContentType.
type ExitZarTransactionJSONRequestBody = StablecoinSystemZarexitTxRequest

// ApproveAndJoinZarTransactionJSONRequestBody defines body for ApproveAndJoinZarTransaction for application/json ContentType.
type ApproveAndJoinZarTransactionJSONRequestBody = StablecoinSystemZarjoinTxRequest

// LiquidateVaultTransactionJSONRequestBody defines body for LiquidateVaultTransaction for application/json ContentType.
type LiquidateVaultTransactionJSONRequestBody = StablecoinSystemBarkTxRequest

// CreateStableCoinVaultJSONRequestBody defines body for CreateStableCoinVault for application/json ContentType.
type CreateStableCoinVaultJSONRequestBody = StablecoinSystemCreateVaultTxRequest

// DepositStableCoinCollateralJSONRequestBody defines body for DepositStableCoinCollateral for application/json ContentType.
type DepositStableCoinCollateralJSONRequestBody = StablecoinSystemDepositCollateralTxRequest

// MintZarTransactionJSONRequestBody defines body for MintZarTransaction for application/json ContentType.
type MintZarTransactionJSONRequestBody = StablecoinSystemMintZarTxRequest

// RepayZarTransactionJSONRequestBody defines body for RepayZarTransaction for application/json ContentType.
type RepayZarTransactionJSONRequestBody = StablecoinSystemRepayZarTxRequest

// WithdrawCollateralTransactionJSONRequestBody defines body for WithdrawCollateralTransaction for application/json ContentType.
type WithdrawCollateralTransactionJSONRequestBody = StablecoinSystemWithdrawCollateralTxRequest

// CollectStakingRewardJSONRequestBody defines body for CollectStakingReward for application/json ContentType.
type CollectStakingRewardJSONRequestBody = StakingCollectRewardTxRequest

// StakeToStakingContractJSONRequestBody defines body for StakeToStakingContract for application/json ContentType.
type StakeToStakingContractJSONRequestBody = StakingStakeTxRequest

// WithdrawStakedAssetJSONRequestBody defines body for WithdrawStakedAsset for application/json ContentType.
type WithdrawStakedAssetJSONRequestBody = StakingWithdrawTxRequest

// GetSwapQuoteJSONRequestBody defines body for GetSwapQuote for application/json ContentType.
type GetSwapQuoteJSONRequestBody = QuoteRequest

// AsPreparedTx returns the union data inside the ChainActivityStepData as a PreparedTx
func (t ChainActivityStepData) AsPreparedTx() (PreparedTx, error) {
	var body PreparedTx
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreparedTx overwrites any union data inside the ChainActivityStepData as the provided PreparedTx
func (t *ChainActivityStepData) FromPreparedTx(v PreparedTx) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreparedTx performs a merge with any union data inside the ChainActivityStepData, using the provided PreparedTx
func (t *ChainActivityStepData) MergePreparedTx(v PreparedTx) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEIP712SignRequest returns the union data inside the ChainActivityStepData as a EIP712SignRequest
func (t ChainActivityStepData) AsEIP712SignRequest() (EIP712SignRequest, error) {
	var body EIP712SignRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEIP712SignRequest overwrites any union data inside the ChainActivityStepData as the provided EIP712SignRequest
func (t *ChainActivityStepData) FromEIP712SignRequest(v EIP712SignRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEIP712SignRequest performs a merge with any union data inside the ChainActivityStepData, using the provided EIP712SignRequest
func (t *ChainActivityStepData) MergeEIP712SignRequest(v EIP712SignRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPersonalSignRequest returns the union data inside the ChainActivityStepData as a PersonalSignRequest
func (t ChainActivityStepData) AsPersonalSignRequest() (PersonalSignRequest, error) {
	var body PersonalSignRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPersonalSignRequest overwrites any union data inside the ChainActivityStepData as the provided PersonalSignRequest
func (t *ChainActivityStepData) FromPersonalSignRequest(v PersonalSignRequest) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePersonalSignRequest performs a merge with any union data inside the ChainActivityStepData, using the provided PersonalSignRequest
func (t *ChainActivityStepData) MergePersonalSignRequest(v PersonalSignRequest) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ChainActivityStepData) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ChainActivityStepData) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAccountByAddress request
	GetAccountByAddress(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAddresses request
	GetAllAddresses(ctx context.Context, params *GetAllAddressesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllIlks request
	GetAllIlks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIlkByName request
	GetIlkByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserBorrows request
	GetUserBorrows(ctx context.Context, params *GetUserBorrowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserDeposits request
	GetUserDeposits(ctx context.Context, params *GetUserDepositsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchReserveDataByAsset request
	FetchReserveDataByAsset(ctx context.Context, params *FetchReserveDataByAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLendingPoolBorrowWithBody request with any body
	CreateLendingPoolBorrowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLendingPoolBorrow(ctx context.Context, body CreateLendingPoolBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLendingPoolDepositWithBody request with any body
	CreateLendingPoolDepositWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLendingPoolDeposit(ctx context.Context, body CreateLendingPoolDepositJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLendingPoolRepayWithBody request with any body
	CreateLendingPoolRepayWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLendingPoolRepay(ctx context.Context, body CreateLendingPoolRepayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetLendingPoolAssetCollateralWithBody request with any body
	SetLendingPoolAssetCollateralWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetLendingPoolAssetCollateral(ctx context.Context, body SetLendingPoolAssetCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLendingPoolWithdrawWithBody request with any body
	CreateLendingPoolWithdrawWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLendingPoolWithdraw(ctx context.Context, body CreateLendingPoolWithdrawJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogsByTransactionHash request
	GetLogsByTransactionHash(ctx context.Context, txHash string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnfilledOrders request
	GetUnfilledOrders(ctx context.Context, params *GetUnfilledOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SyncOrderWithBody request with any body
	SyncOrderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SyncOrder(ctx context.Context, body SyncOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSingleTokenPermit request
	GetSingleTokenPermit(ctx context.Context, params *GetSingleTokenPermitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScoreboard request
	GetScoreboard(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPrices request
	ListPrices(ctx context.Context, params *ListPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExitGemTransactionWithBody request with any body
	ExitGemTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExitGemTransaction(ctx context.Context, body ExitGemTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetAuctionTransactionWithBody request with any body
	ResetAuctionTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetAuctionTransaction(ctx context.Context, body ResetAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TakeAuctionTransactionWithBody request with any body
	TakeAuctionTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TakeAuctionTransaction(ctx context.Context, body TakeAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExitZarTransactionWithBody request with any body
	ExitZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExitZarTransaction(ctx context.Context, body ExitZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ApproveAndJoinZarTransactionWithBody request with any body
	ApproveAndJoinZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ApproveAndJoinZarTransaction(ctx context.Context, body ApproveAndJoinZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LiquidateVaultTransactionWithBody request with any body
	LiquidateVaultTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LiquidateVaultTransaction(ctx context.Context, body LiquidateVaultTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStableCoinVaultWithBody request with any body
	CreateStableCoinVaultWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateStableCoinVault(ctx context.Context, body CreateStableCoinVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DepositStableCoinCollateralWithBody request with any body
	DepositStableCoinCollateralWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DepositStableCoinCollateral(ctx context.Context, body DepositStableCoinCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MintZarTransactionWithBody request with any body
	MintZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MintZarTransaction(ctx context.Context, body MintZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RepayZarTransactionWithBody request with any body
	RepayZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RepayZarTransaction(ctx context.Context, body RepayZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WithdrawCollateralTransactionWithBody request with any body
	WithdrawCollateralTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WithdrawCollateralTransaction(ctx context.Context, body WithdrawCollateralTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStakingPlans request
	GetStakingPlans(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserStakingStats request
	GetUserStakingStats(ctx context.Context, params *GetUserStakingStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollectStakingRewardWithBody request with any body
	CollectStakingRewardWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CollectStakingReward(ctx context.Context, body CollectStakingRewardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StakeToStakingContractWithBody request with any body
	StakeToStakingContractWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StakeToStakingContract(ctx context.Context, body StakeToStakingContractJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WithdrawStakedAssetWithBody request with any body
	WithdrawStakedAssetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WithdrawStakedAsset(ctx context.Context, body WithdrawStakedAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollectorData request
	GetCollectorData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSwapQuoteWithBody request with any body
	GetSwapQuoteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetSwapQuote(ctx context.Context, body GetSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVaultsByOwner request
	GetVaultsByOwner(ctx context.Context, params *GetVaultsByOwnerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVaultById request
	GetVaultById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVaultEventsById request
	GetVaultEventsById(ctx context.Context, id int, params *GetVaultEventsByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnfilledOrdersWebsocket request
	GetUnfilledOrdersWebsocket(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAccountByAddress(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountByAddressRequest(c.Server, address)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAddresses(ctx context.Context, params *GetAllAddressesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAddressesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllIlks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllIlksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIlkByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIlkByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserBorrows(ctx context.Context, params *GetUserBorrowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserBorrowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserDeposits(ctx context.Context, params *GetUserDepositsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserDepositsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchReserveDataByAsset(ctx context.Context, params *FetchReserveDataByAssetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchReserveDataByAssetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolBorrowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolBorrowRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolBorrow(ctx context.Context, body CreateLendingPoolBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolBorrowRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolDepositWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolDepositRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolDeposit(ctx context.Context, body CreateLendingPoolDepositJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolDepositRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolRepayWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolRepayRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolRepay(ctx context.Context, body CreateLendingPoolRepayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolRepayRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetLendingPoolAssetCollateralWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetLendingPoolAssetCollateralRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetLendingPoolAssetCollateral(ctx context.Context, body SetLendingPoolAssetCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetLendingPoolAssetCollateralRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolWithdrawWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolWithdrawRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLendingPoolWithdraw(ctx context.Context, body CreateLendingPoolWithdrawJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLendingPoolWithdrawRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogsByTransactionHash(ctx context.Context, txHash string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogsByTransactionHashRequest(c.Server, txHash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnfilledOrders(ctx context.Context, params *GetUnfilledOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnfilledOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncOrderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncOrderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SyncOrder(ctx context.Context, body SyncOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSyncOrderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSingleTokenPermit(ctx context.Context, params *GetSingleTokenPermitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSingleTokenPermitRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScoreboard(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScoreboardRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPrices(ctx context.Context, params *ListPricesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPricesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExitGemTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExitGemTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExitGemTransaction(ctx context.Context, body ExitGemTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExitGemTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetAuctionTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetAuctionTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetAuctionTransaction(ctx context.Context, body ResetAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetAuctionTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TakeAuctionTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTakeAuctionTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TakeAuctionTransaction(ctx context.Context, body TakeAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTakeAuctionTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExitZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExitZarTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExitZarTransaction(ctx context.Context, body ExitZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExitZarTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveAndJoinZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveAndJoinZarTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ApproveAndJoinZarTransaction(ctx context.Context, body ApproveAndJoinZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewApproveAndJoinZarTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LiquidateVaultTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLiquidateVaultTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LiquidateVaultTransaction(ctx context.Context, body LiquidateVaultTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLiquidateVaultTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStableCoinVaultWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStableCoinVaultRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStableCoinVault(ctx context.Context, body CreateStableCoinVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStableCoinVaultRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DepositStableCoinCollateralWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDepositStableCoinCollateralRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DepositStableCoinCollateral(ctx context.Context, body DepositStableCoinCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDepositStableCoinCollateralRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MintZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMintZarTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MintZarTransaction(ctx context.Context, body MintZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMintZarTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepayZarTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepayZarTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepayZarTransaction(ctx context.Context, body RepayZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepayZarTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WithdrawCollateralTransactionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWithdrawCollateralTransactionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WithdrawCollateralTransaction(ctx context.Context, body WithdrawCollateralTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWithdrawCollateralTransactionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStakingPlans(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStakingPlansRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserStakingStats(ctx context.Context, params *GetUserStakingStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserStakingStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectStakingRewardWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectStakingRewardRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectStakingReward(ctx context.Context, body CollectStakingRewardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectStakingRewardRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StakeToStakingContractWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStakeToStakingContractRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StakeToStakingContract(ctx context.Context, body StakeToStakingContractJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStakeToStakingContractRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WithdrawStakedAssetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWithdrawStakedAssetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WithdrawStakedAsset(ctx context.Context, body WithdrawStakedAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWithdrawStakedAssetRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollectorData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectorDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSwapQuoteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSwapQuoteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSwapQuote(ctx context.Context, body GetSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSwapQuoteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVaultsByOwner(ctx context.Context, params *GetVaultsByOwnerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVaultsByOwnerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVaultById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVaultByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVaultEventsById(ctx context.Context, id int, params *GetVaultEventsByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVaultEventsByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnfilledOrdersWebsocket(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnfilledOrdersWebsocketRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAccountByAddressRequest generates requests for GetAccountByAddress
func NewGetAccountByAddressRequest(server string, address string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "address", runtime.ParamLocationPath, address)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllAddressesRequest generates requests for GetAllAddresses
func NewGetAllAddressesRequest(server string, params *GetAllAddressesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/addresses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllIlksRequest generates requests for GetAllIlks
func NewGetAllIlksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/ilks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIlkByNameRequest generates requests for GetIlkByName
func NewGetIlkByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/ilks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserBorrowsRequest generates requests for GetUserBorrows
func NewGetUserBorrowsRequest(server string, params *GetUserBorrowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/borrows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reserve != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reserve", runtime.ParamLocationQuery, *params.Reserve); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserDepositsRequest generates requests for GetUserDeposits
func NewGetUserDepositsRequest(server string, params *GetUserDepositsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/deposits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reserve != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reserve", runtime.ParamLocationQuery, *params.Reserve); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFetchReserveDataByAssetRequest generates requests for FetchReserveDataByAsset
func NewFetchReserveDataByAssetRequest(server string, params *FetchReserveDataByAssetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/reserves")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Asset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "asset", runtime.ParamLocationQuery, *params.Asset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLendingPoolBorrowRequest calls the generic CreateLendingPoolBorrow builder with application/json body
func NewCreateLendingPoolBorrowRequest(server string, body CreateLendingPoolBorrowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLendingPoolBorrowRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLendingPoolBorrowRequestWithBody generates requests for CreateLendingPoolBorrow with any type of body
func NewCreateLendingPoolBorrowRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/tx/borrow")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLendingPoolDepositRequest calls the generic CreateLendingPoolDeposit builder with application/json body
func NewCreateLendingPoolDepositRequest(server string, body CreateLendingPoolDepositJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLendingPoolDepositRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLendingPoolDepositRequestWithBody generates requests for CreateLendingPoolDeposit with any type of body
func NewCreateLendingPoolDepositRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/tx/deposit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLendingPoolRepayRequest calls the generic CreateLendingPoolRepay builder with application/json body
func NewCreateLendingPoolRepayRequest(server string, body CreateLendingPoolRepayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLendingPoolRepayRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLendingPoolRepayRequestWithBody generates requests for CreateLendingPoolRepay with any type of body
func NewCreateLendingPoolRepayRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/tx/repay")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetLendingPoolAssetCollateralRequest calls the generic SetLendingPoolAssetCollateral builder with application/json body
func NewSetLendingPoolAssetCollateralRequest(server string, body SetLendingPoolAssetCollateralJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetLendingPoolAssetCollateralRequestWithBody(server, "application/json", bodyReader)
}

// NewSetLendingPoolAssetCollateralRequestWithBody generates requests for SetLendingPoolAssetCollateral with any type of body
func NewSetLendingPoolAssetCollateralRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/tx/useassetascollateral")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateLendingPoolWithdrawRequest calls the generic CreateLendingPoolWithdraw builder with application/json body
func NewCreateLendingPoolWithdrawRequest(server string, body CreateLendingPoolWithdrawJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLendingPoolWithdrawRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLendingPoolWithdrawRequestWithBody generates requests for CreateLendingPoolWithdraw with any type of body
func NewCreateLendingPoolWithdrawRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/lendingpool/tx/withdraw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLogsByTransactionHashRequest generates requests for GetLogsByTransactionHash
func NewGetLogsByTransactionHashRequest(server string, txHash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "txHash", runtime.ParamLocationPath, txHash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/logs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUnfilledOrdersRequest generates requests for GetUnfilledOrders
func NewGetUnfilledOrdersRequest(server string, params *GetUnfilledOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Hash != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hash", runtime.ParamLocationQuery, *params.Hash); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offerer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offerer", runtime.ParamLocationQuery, *params.Offerer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filler != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filler", runtime.ParamLocationQuery, *params.Filler); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DecayStartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "decayStartTime", runtime.ParamLocationQuery, *params.DecayStartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DecayEndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "decayEndTime", runtime.ParamLocationQuery, *params.DecayEndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Deadline != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deadline", runtime.ParamLocationQuery, *params.Deadline); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSyncOrderRequest calls the generic SyncOrder builder with application/json body
func NewSyncOrderRequest(server string, body SyncOrderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSyncOrderRequestWithBody(server, "application/json", bodyReader)
}

// NewSyncOrderRequestWithBody generates requests for SyncOrder with any type of body
func NewSyncOrderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/orders/sync")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSingleTokenPermitRequest generates requests for GetSingleTokenPermit
func NewGetSingleTokenPermitRequest(server string, params *GetSingleTokenPermitParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/permit/single")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, params.User); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScoreboardRequest generates requests for GetScoreboard
func NewGetScoreboardRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/points/scoreboard")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPricesRequest generates requests for ListPrices
func NewListPricesRequest(server string, params *ListPricesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/prices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Symbol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "symbol", runtime.ParamLocationQuery, *params.Symbol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExitGemTransactionRequest calls the generic ExitGemTransaction builder with application/json body
func NewExitGemTransactionRequest(server string, body ExitGemTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExitGemTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewExitGemTransactionRequestWithBody generates requests for ExitGemTransaction with any type of body
func NewExitGemTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/auctions/tx/gemexit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetAuctionTransactionRequest calls the generic ResetAuctionTransaction builder with application/json body
func NewResetAuctionTransactionRequest(server string, body ResetAuctionTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetAuctionTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewResetAuctionTransactionRequestWithBody generates requests for ResetAuctionTransaction with any type of body
func NewResetAuctionTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/auctions/tx/redo")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTakeAuctionTransactionRequest calls the generic TakeAuctionTransaction builder with application/json body
func NewTakeAuctionTransactionRequest(server string, body TakeAuctionTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTakeAuctionTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewTakeAuctionTransactionRequestWithBody generates requests for TakeAuctionTransaction with any type of body
func NewTakeAuctionTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/auctions/tx/take")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExitZarTransactionRequest calls the generic ExitZarTransaction builder with application/json body
func NewExitZarTransactionRequest(server string, body ExitZarTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExitZarTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewExitZarTransactionRequestWithBody generates requests for ExitZarTransaction with any type of body
func NewExitZarTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/auctions/tx/zarexit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewApproveAndJoinZarTransactionRequest calls the generic ApproveAndJoinZarTransaction builder with application/json body
func NewApproveAndJoinZarTransactionRequest(server string, body ApproveAndJoinZarTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewApproveAndJoinZarTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewApproveAndJoinZarTransactionRequestWithBody generates requests for ApproveAndJoinZarTransaction with any type of body
func NewApproveAndJoinZarTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/auctions/tx/zarjoin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLiquidateVaultTransactionRequest calls the generic LiquidateVaultTransaction builder with application/json body
func NewLiquidateVaultTransactionRequest(server string, body LiquidateVaultTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLiquidateVaultTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewLiquidateVaultTransactionRequestWithBody generates requests for LiquidateVaultTransaction with any type of body
func NewLiquidateVaultTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/tx/bark")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateStableCoinVaultRequest calls the generic CreateStableCoinVault builder with application/json body
func NewCreateStableCoinVaultRequest(server string, body CreateStableCoinVaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStableCoinVaultRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateStableCoinVaultRequestWithBody generates requests for CreateStableCoinVault with any type of body
func NewCreateStableCoinVaultRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/tx/createvault")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDepositStableCoinCollateralRequest calls the generic DepositStableCoinCollateral builder with application/json body
func NewDepositStableCoinCollateralRequest(server string, body DepositStableCoinCollateralJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDepositStableCoinCollateralRequestWithBody(server, "application/json", bodyReader)
}

// NewDepositStableCoinCollateralRequestWithBody generates requests for DepositStableCoinCollateral with any type of body
func NewDepositStableCoinCollateralRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/tx/depositcollateral")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMintZarTransactionRequest calls the generic MintZarTransaction builder with application/json body
func NewMintZarTransactionRequest(server string, body MintZarTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMintZarTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewMintZarTransactionRequestWithBody generates requests for MintZarTransaction with any type of body
func NewMintZarTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/tx/mintzar")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRepayZarTransactionRequest calls the generic RepayZarTransaction builder with application/json body
func NewRepayZarTransactionRequest(server string, body RepayZarTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRepayZarTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewRepayZarTransactionRequestWithBody generates requests for RepayZarTransaction with any type of body
func NewRepayZarTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/tx/repayzar")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWithdrawCollateralTransactionRequest calls the generic WithdrawCollateralTransaction builder with application/json body
func NewWithdrawCollateralTransactionRequest(server string, body WithdrawCollateralTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWithdrawCollateralTransactionRequestWithBody(server, "application/json", bodyReader)
}

// NewWithdrawCollateralTransactionRequestWithBody generates requests for WithdrawCollateralTransaction with any type of body
func NewWithdrawCollateralTransactionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stablecoinsystem/tx/withdrawcollateral")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStakingPlansRequest generates requests for GetStakingPlans
func NewGetStakingPlansRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/staking/plans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserStakingStatsRequest generates requests for GetUserStakingStats
func NewGetUserStakingStatsRequest(server string, params *GetUserStakingStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/staking/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Address != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "address", runtime.ParamLocationQuery, *params.Address); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Active != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCollectStakingRewardRequest calls the generic CollectStakingReward builder with application/json body
func NewCollectStakingRewardRequest(server string, body CollectStakingRewardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCollectStakingRewardRequestWithBody(server, "application/json", bodyReader)
}

// NewCollectStakingRewardRequestWithBody generates requests for CollectStakingReward with any type of body
func NewCollectStakingRewardRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/staking/tx/collectreward")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStakeToStakingContractRequest calls the generic StakeToStakingContract builder with application/json body
func NewStakeToStakingContractRequest(server string, body StakeToStakingContractJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStakeToStakingContractRequestWithBody(server, "application/json", bodyReader)
}

// NewStakeToStakingContractRequestWithBody generates requests for StakeToStakingContract with any type of body
func NewStakeToStakingContractRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/staking/tx/stake")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWithdrawStakedAssetRequest calls the generic WithdrawStakedAsset builder with application/json body
func NewWithdrawStakedAssetRequest(server string, body WithdrawStakedAssetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWithdrawStakedAssetRequestWithBody(server, "application/json", bodyReader)
}

// NewWithdrawStakedAssetRequestWithBody generates requests for WithdrawStakedAsset with any type of body
func NewWithdrawStakedAssetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/staking/tx/withdraw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCollectorDataRequest generates requests for GetCollectorData
func NewGetCollectorDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSwapQuoteRequest calls the generic GetSwapQuote builder with application/json body
func NewGetSwapQuoteRequest(server string, body GetSwapQuoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetSwapQuoteRequestWithBody(server, "application/json", bodyReader)
}

// NewGetSwapQuoteRequestWithBody generates requests for GetSwapQuote with any type of body
func NewGetSwapQuoteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/swap/quote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVaultsByOwnerRequest generates requests for GetVaultsByOwner
func NewGetVaultsByOwnerRequest(server string, params *GetVaultsByOwnerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/vaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Owner != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owner", runtime.ParamLocationQuery, *params.Owner); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVaultByIdRequest generates requests for GetVaultById
func NewGetVaultByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/vaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVaultEventsByIdRequest generates requests for GetVaultEventsById
func NewGetVaultEventsByIdRequest(server string, id int, params *GetVaultEventsByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/vaults/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUnfilledOrdersWebsocketRequest generates requests for GetUnfilledOrdersWebsocket
func NewGetUnfilledOrdersWebsocketRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/ws")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAccountByAddressWithResponse request
	GetAccountByAddressWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetAccountByAddressResponse, error)

	// GetAllAddressesWithResponse request
	GetAllAddressesWithResponse(ctx context.Context, params *GetAllAddressesParams, reqEditors ...RequestEditorFn) (*GetAllAddressesResponse, error)

	// GetAllIlksWithResponse request
	GetAllIlksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllIlksResponse, error)

	// GetIlkByNameWithResponse request
	GetIlkByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetIlkByNameResponse, error)

	// GetUserBorrowsWithResponse request
	GetUserBorrowsWithResponse(ctx context.Context, params *GetUserBorrowsParams, reqEditors ...RequestEditorFn) (*GetUserBorrowsResponse, error)

	// GetUserDepositsWithResponse request
	GetUserDepositsWithResponse(ctx context.Context, params *GetUserDepositsParams, reqEditors ...RequestEditorFn) (*GetUserDepositsResponse, error)

	// FetchReserveDataByAssetWithResponse request
	FetchReserveDataByAssetWithResponse(ctx context.Context, params *FetchReserveDataByAssetParams, reqEditors ...RequestEditorFn) (*FetchReserveDataByAssetResponse, error)

	// CreateLendingPoolBorrowWithBodyWithResponse request with any body
	CreateLendingPoolBorrowWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolBorrowResponse, error)

	CreateLendingPoolBorrowWithResponse(ctx context.Context, body CreateLendingPoolBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolBorrowResponse, error)

	// CreateLendingPoolDepositWithBodyWithResponse request with any body
	CreateLendingPoolDepositWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolDepositResponse, error)

	CreateLendingPoolDepositWithResponse(ctx context.Context, body CreateLendingPoolDepositJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolDepositResponse, error)

	// CreateLendingPoolRepayWithBodyWithResponse request with any body
	CreateLendingPoolRepayWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolRepayResponse, error)

	CreateLendingPoolRepayWithResponse(ctx context.Context, body CreateLendingPoolRepayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolRepayResponse, error)

	// SetLendingPoolAssetCollateralWithBodyWithResponse request with any body
	SetLendingPoolAssetCollateralWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetLendingPoolAssetCollateralResponse, error)

	SetLendingPoolAssetCollateralWithResponse(ctx context.Context, body SetLendingPoolAssetCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*SetLendingPoolAssetCollateralResponse, error)

	// CreateLendingPoolWithdrawWithBodyWithResponse request with any body
	CreateLendingPoolWithdrawWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolWithdrawResponse, error)

	CreateLendingPoolWithdrawWithResponse(ctx context.Context, body CreateLendingPoolWithdrawJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolWithdrawResponse, error)

	// GetLogsByTransactionHashWithResponse request
	GetLogsByTransactionHashWithResponse(ctx context.Context, txHash string, reqEditors ...RequestEditorFn) (*GetLogsByTransactionHashResponse, error)

	// GetUnfilledOrdersWithResponse request
	GetUnfilledOrdersWithResponse(ctx context.Context, params *GetUnfilledOrdersParams, reqEditors ...RequestEditorFn) (*GetUnfilledOrdersResponse, error)

	// SyncOrderWithBodyWithResponse request with any body
	SyncOrderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncOrderResponse, error)

	SyncOrderWithResponse(ctx context.Context, body SyncOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncOrderResponse, error)

	// GetSingleTokenPermitWithResponse request
	GetSingleTokenPermitWithResponse(ctx context.Context, params *GetSingleTokenPermitParams, reqEditors ...RequestEditorFn) (*GetSingleTokenPermitResponse, error)

	// GetScoreboardWithResponse request
	GetScoreboardWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetScoreboardResponse, error)

	// ListPricesWithResponse request
	ListPricesWithResponse(ctx context.Context, params *ListPricesParams, reqEditors ...RequestEditorFn) (*ListPricesResponse, error)

	// ExitGemTransactionWithBodyWithResponse request with any body
	ExitGemTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExitGemTransactionResponse, error)

	ExitGemTransactionWithResponse(ctx context.Context, body ExitGemTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExitGemTransactionResponse, error)

	// ResetAuctionTransactionWithBodyWithResponse request with any body
	ResetAuctionTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetAuctionTransactionResponse, error)

	ResetAuctionTransactionWithResponse(ctx context.Context, body ResetAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetAuctionTransactionResponse, error)

	// TakeAuctionTransactionWithBodyWithResponse request with any body
	TakeAuctionTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TakeAuctionTransactionResponse, error)

	TakeAuctionTransactionWithResponse(ctx context.Context, body TakeAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TakeAuctionTransactionResponse, error)

	// ExitZarTransactionWithBodyWithResponse request with any body
	ExitZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExitZarTransactionResponse, error)

	ExitZarTransactionWithResponse(ctx context.Context, body ExitZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExitZarTransactionResponse, error)

	// ApproveAndJoinZarTransactionWithBodyWithResponse request with any body
	ApproveAndJoinZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApproveAndJoinZarTransactionResponse, error)

	ApproveAndJoinZarTransactionWithResponse(ctx context.Context, body ApproveAndJoinZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ApproveAndJoinZarTransactionResponse, error)

	// LiquidateVaultTransactionWithBodyWithResponse request with any body
	LiquidateVaultTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LiquidateVaultTransactionResponse, error)

	LiquidateVaultTransactionWithResponse(ctx context.Context, body LiquidateVaultTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*LiquidateVaultTransactionResponse, error)

	// CreateStableCoinVaultWithBodyWithResponse request with any body
	CreateStableCoinVaultWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStableCoinVaultResponse, error)

	CreateStableCoinVaultWithResponse(ctx context.Context, body CreateStableCoinVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStableCoinVaultResponse, error)

	// DepositStableCoinCollateralWithBodyWithResponse request with any body
	DepositStableCoinCollateralWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DepositStableCoinCollateralResponse, error)

	DepositStableCoinCollateralWithResponse(ctx context.Context, body DepositStableCoinCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*DepositStableCoinCollateralResponse, error)

	// MintZarTransactionWithBodyWithResponse request with any body
	MintZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MintZarTransactionResponse, error)

	MintZarTransactionWithResponse(ctx context.Context, body MintZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*MintZarTransactionResponse, error)

	// RepayZarTransactionWithBodyWithResponse request with any body
	RepayZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepayZarTransactionResponse, error)

	RepayZarTransactionWithResponse(ctx context.Context, body RepayZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*RepayZarTransactionResponse, error)

	// WithdrawCollateralTransactionWithBodyWithResponse request with any body
	WithdrawCollateralTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WithdrawCollateralTransactionResponse, error)

	WithdrawCollateralTransactionWithResponse(ctx context.Context, body WithdrawCollateralTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*WithdrawCollateralTransactionResponse, error)

	// GetStakingPlansWithResponse request
	GetStakingPlansWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStakingPlansResponse, error)

	// GetUserStakingStatsWithResponse request
	GetUserStakingStatsWithResponse(ctx context.Context, params *GetUserStakingStatsParams, reqEditors ...RequestEditorFn) (*GetUserStakingStatsResponse, error)

	// CollectStakingRewardWithBodyWithResponse request with any body
	CollectStakingRewardWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollectStakingRewardResponse, error)

	CollectStakingRewardWithResponse(ctx context.Context, body CollectStakingRewardJSONRequestBody, reqEditors ...RequestEditorFn) (*CollectStakingRewardResponse, error)

	// StakeToStakingContractWithBodyWithResponse request with any body
	StakeToStakingContractWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StakeToStakingContractResponse, error)

	StakeToStakingContractWithResponse(ctx context.Context, body StakeToStakingContractJSONRequestBody, reqEditors ...RequestEditorFn) (*StakeToStakingContractResponse, error)

	// WithdrawStakedAssetWithBodyWithResponse request with any body
	WithdrawStakedAssetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WithdrawStakedAssetResponse, error)

	WithdrawStakedAssetWithResponse(ctx context.Context, body WithdrawStakedAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*WithdrawStakedAssetResponse, error)

	// GetCollectorDataWithResponse request
	GetCollectorDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCollectorDataResponse, error)

	// GetSwapQuoteWithBodyWithResponse request with any body
	GetSwapQuoteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetSwapQuoteResponse, error)

	GetSwapQuoteWithResponse(ctx context.Context, body GetSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSwapQuoteResponse, error)

	// GetVaultsByOwnerWithResponse request
	GetVaultsByOwnerWithResponse(ctx context.Context, params *GetVaultsByOwnerParams, reqEditors ...RequestEditorFn) (*GetVaultsByOwnerResponse, error)

	// GetVaultByIdWithResponse request
	GetVaultByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetVaultByIdResponse, error)

	// GetVaultEventsByIdWithResponse request
	GetVaultEventsByIdWithResponse(ctx context.Context, id int, params *GetVaultEventsByIdParams, reqEditors ...RequestEditorFn) (*GetVaultEventsByIdResponse, error)

	// GetUnfilledOrdersWebsocketWithResponse request
	GetUnfilledOrdersWebsocketWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUnfilledOrdersWebsocketResponse, error)
}

type GetAccountByAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Account
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAccountByAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountByAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAddressesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddressResponse
}

// Status returns HTTPResponse.Status
func (r GetAllAddressesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAddressesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllIlksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IlksResponse
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAllIlksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllIlksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIlkByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ilk
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetIlkByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIlkByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserBorrowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserBorrowsResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUserBorrowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserBorrowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserDepositsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserDepositsResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUserDepositsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserDepositsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchReserveDataByAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FormattedReserveData
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r FetchReserveDataByAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchReserveDataByAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLendingPoolBorrowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LendingpoolBorrowTxResponse
	JSON400      *UserError
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateLendingPoolBorrowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLendingPoolBorrowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLendingPoolDepositResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LendingpoolDepositTxResponse
	JSON400      *UserError
	JSON500      *UserError
}

// Status returns HTTPResponse.Status
func (r CreateLendingPoolDepositResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLendingPoolDepositResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLendingPoolRepayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LendingpoolRepayTxResponse
	JSON400      *UserError
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateLendingPoolRepayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLendingPoolRepayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetLendingPoolAssetCollateralResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LendingpoolUseAssetAsCollateralTxResponse
	JSON400      *UserError
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r SetLendingPoolAssetCollateralResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetLendingPoolAssetCollateralResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLendingPoolWithdrawResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LendingpoolWithdrawTxResponse
	JSON400      *UserError
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateLendingPoolWithdrawResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLendingPoolWithdrawResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogsByTransactionHashResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventDetailsResponse
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetLogsByTransactionHashResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogsByTransactionHashResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnfilledOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrderResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUnfilledOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnfilledOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SyncOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Error
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r SyncOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SyncOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSingleTokenPermitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermitSingle
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSingleTokenPermitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSingleTokenPermitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScoreboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Scoreboard
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetScoreboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScoreboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPricesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PriceListResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ListPricesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPricesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExitGemTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ExitGemTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExitGemTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetAuctionTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ResetAuctionTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetAuctionTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TakeAuctionTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r TakeAuctionTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TakeAuctionTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExitZarTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ExitZarTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExitZarTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ApproveAndJoinZarTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r ApproveAndJoinZarTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ApproveAndJoinZarTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LiquidateVaultTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r LiquidateVaultTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LiquidateVaultTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStableCoinVaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateStableCoinVaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStableCoinVaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DepositStableCoinCollateralResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DepositStableCoinCollateralResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DepositStableCoinCollateralResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MintZarTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r MintZarTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MintZarTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RepayZarTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r RepayZarTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RepayZarTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WithdrawCollateralTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChainActivity
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r WithdrawCollateralTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WithdrawCollateralTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStakingPlansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StakePlansResponse
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetStakingPlansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStakingPlansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserStakingStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserStakesResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetUserStakingStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserStakingStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollectStakingRewardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StakingCollectRewardTxResponse
	JSON400      *UserError
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CollectStakingRewardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectStakingRewardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StakeToStakingContractResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StakingStakeTxResponse
	JSON400      *UserError
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r StakeToStakingContractResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StakeToStakingContractResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WithdrawStakedAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StakingWithdrawTxResponse
	JSON400      *UserError
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r WithdrawStakedAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WithdrawStakedAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectorDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Stats
}

// Status returns HTTPResponse.Status
func (r GetCollectorDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectorDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSwapQuoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuoteResponse
	JSON400      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetSwapQuoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSwapQuoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVaultsByOwnerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VaultsResponse
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVaultsByOwnerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVaultsByOwnerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVaultByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Vault
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVaultByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVaultByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVaultEventsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VaultEventsResponse
	JSON400      *Error
	JSON404      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetVaultEventsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVaultEventsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnfilledOrdersWebsocketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetUnfilledOrdersWebsocketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnfilledOrdersWebsocketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAccountByAddressWithResponse request returning *GetAccountByAddressResponse
func (c *ClientWithResponses) GetAccountByAddressWithResponse(ctx context.Context, address string, reqEditors ...RequestEditorFn) (*GetAccountByAddressResponse, error) {
	rsp, err := c.GetAccountByAddress(ctx, address, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountByAddressResponse(rsp)
}

// GetAllAddressesWithResponse request returning *GetAllAddressesResponse
func (c *ClientWithResponses) GetAllAddressesWithResponse(ctx context.Context, params *GetAllAddressesParams, reqEditors ...RequestEditorFn) (*GetAllAddressesResponse, error) {
	rsp, err := c.GetAllAddresses(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAddressesResponse(rsp)
}

// GetAllIlksWithResponse request returning *GetAllIlksResponse
func (c *ClientWithResponses) GetAllIlksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllIlksResponse, error) {
	rsp, err := c.GetAllIlks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllIlksResponse(rsp)
}

// GetIlkByNameWithResponse request returning *GetIlkByNameResponse
func (c *ClientWithResponses) GetIlkByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetIlkByNameResponse, error) {
	rsp, err := c.GetIlkByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIlkByNameResponse(rsp)
}

// GetUserBorrowsWithResponse request returning *GetUserBorrowsResponse
func (c *ClientWithResponses) GetUserBorrowsWithResponse(ctx context.Context, params *GetUserBorrowsParams, reqEditors ...RequestEditorFn) (*GetUserBorrowsResponse, error) {
	rsp, err := c.GetUserBorrows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserBorrowsResponse(rsp)
}

// GetUserDepositsWithResponse request returning *GetUserDepositsResponse
func (c *ClientWithResponses) GetUserDepositsWithResponse(ctx context.Context, params *GetUserDepositsParams, reqEditors ...RequestEditorFn) (*GetUserDepositsResponse, error) {
	rsp, err := c.GetUserDeposits(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserDepositsResponse(rsp)
}

// FetchReserveDataByAssetWithResponse request returning *FetchReserveDataByAssetResponse
func (c *ClientWithResponses) FetchReserveDataByAssetWithResponse(ctx context.Context, params *FetchReserveDataByAssetParams, reqEditors ...RequestEditorFn) (*FetchReserveDataByAssetResponse, error) {
	rsp, err := c.FetchReserveDataByAsset(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchReserveDataByAssetResponse(rsp)
}

// CreateLendingPoolBorrowWithBodyWithResponse request with arbitrary body returning *CreateLendingPoolBorrowResponse
func (c *ClientWithResponses) CreateLendingPoolBorrowWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolBorrowResponse, error) {
	rsp, err := c.CreateLendingPoolBorrowWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolBorrowResponse(rsp)
}

func (c *ClientWithResponses) CreateLendingPoolBorrowWithResponse(ctx context.Context, body CreateLendingPoolBorrowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolBorrowResponse, error) {
	rsp, err := c.CreateLendingPoolBorrow(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolBorrowResponse(rsp)
}

// CreateLendingPoolDepositWithBodyWithResponse request with arbitrary body returning *CreateLendingPoolDepositResponse
func (c *ClientWithResponses) CreateLendingPoolDepositWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolDepositResponse, error) {
	rsp, err := c.CreateLendingPoolDepositWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolDepositResponse(rsp)
}

func (c *ClientWithResponses) CreateLendingPoolDepositWithResponse(ctx context.Context, body CreateLendingPoolDepositJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolDepositResponse, error) {
	rsp, err := c.CreateLendingPoolDeposit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolDepositResponse(rsp)
}

// CreateLendingPoolRepayWithBodyWithResponse request with arbitrary body returning *CreateLendingPoolRepayResponse
func (c *ClientWithResponses) CreateLendingPoolRepayWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolRepayResponse, error) {
	rsp, err := c.CreateLendingPoolRepayWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolRepayResponse(rsp)
}

func (c *ClientWithResponses) CreateLendingPoolRepayWithResponse(ctx context.Context, body CreateLendingPoolRepayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolRepayResponse, error) {
	rsp, err := c.CreateLendingPoolRepay(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolRepayResponse(rsp)
}

// SetLendingPoolAssetCollateralWithBodyWithResponse request with arbitrary body returning *SetLendingPoolAssetCollateralResponse
func (c *ClientWithResponses) SetLendingPoolAssetCollateralWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetLendingPoolAssetCollateralResponse, error) {
	rsp, err := c.SetLendingPoolAssetCollateralWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetLendingPoolAssetCollateralResponse(rsp)
}

func (c *ClientWithResponses) SetLendingPoolAssetCollateralWithResponse(ctx context.Context, body SetLendingPoolAssetCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*SetLendingPoolAssetCollateralResponse, error) {
	rsp, err := c.SetLendingPoolAssetCollateral(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetLendingPoolAssetCollateralResponse(rsp)
}

// CreateLendingPoolWithdrawWithBodyWithResponse request with arbitrary body returning *CreateLendingPoolWithdrawResponse
func (c *ClientWithResponses) CreateLendingPoolWithdrawWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLendingPoolWithdrawResponse, error) {
	rsp, err := c.CreateLendingPoolWithdrawWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolWithdrawResponse(rsp)
}

func (c *ClientWithResponses) CreateLendingPoolWithdrawWithResponse(ctx context.Context, body CreateLendingPoolWithdrawJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLendingPoolWithdrawResponse, error) {
	rsp, err := c.CreateLendingPoolWithdraw(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLendingPoolWithdrawResponse(rsp)
}

// GetLogsByTransactionHashWithResponse request returning *GetLogsByTransactionHashResponse
func (c *ClientWithResponses) GetLogsByTransactionHashWithResponse(ctx context.Context, txHash string, reqEditors ...RequestEditorFn) (*GetLogsByTransactionHashResponse, error) {
	rsp, err := c.GetLogsByTransactionHash(ctx, txHash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogsByTransactionHashResponse(rsp)
}

// GetUnfilledOrdersWithResponse request returning *GetUnfilledOrdersResponse
func (c *ClientWithResponses) GetUnfilledOrdersWithResponse(ctx context.Context, params *GetUnfilledOrdersParams, reqEditors ...RequestEditorFn) (*GetUnfilledOrdersResponse, error) {
	rsp, err := c.GetUnfilledOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUnfilledOrdersResponse(rsp)
}

// SyncOrderWithBodyWithResponse request with arbitrary body returning *SyncOrderResponse
func (c *ClientWithResponses) SyncOrderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SyncOrderResponse, error) {
	rsp, err := c.SyncOrderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncOrderResponse(rsp)
}

func (c *ClientWithResponses) SyncOrderWithResponse(ctx context.Context, body SyncOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*SyncOrderResponse, error) {
	rsp, err := c.SyncOrder(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSyncOrderResponse(rsp)
}

// GetSingleTokenPermitWithResponse request returning *GetSingleTokenPermitResponse
func (c *ClientWithResponses) GetSingleTokenPermitWithResponse(ctx context.Context, params *GetSingleTokenPermitParams, reqEditors ...RequestEditorFn) (*GetSingleTokenPermitResponse, error) {
	rsp, err := c.GetSingleTokenPermit(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSingleTokenPermitResponse(rsp)
}

// GetScoreboardWithResponse request returning *GetScoreboardResponse
func (c *ClientWithResponses) GetScoreboardWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetScoreboardResponse, error) {
	rsp, err := c.GetScoreboard(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScoreboardResponse(rsp)
}

// ListPricesWithResponse request returning *ListPricesResponse
func (c *ClientWithResponses) ListPricesWithResponse(ctx context.Context, params *ListPricesParams, reqEditors ...RequestEditorFn) (*ListPricesResponse, error) {
	rsp, err := c.ListPrices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPricesResponse(rsp)
}

// ExitGemTransactionWithBodyWithResponse request with arbitrary body returning *ExitGemTransactionResponse
func (c *ClientWithResponses) ExitGemTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExitGemTransactionResponse, error) {
	rsp, err := c.ExitGemTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExitGemTransactionResponse(rsp)
}

func (c *ClientWithResponses) ExitGemTransactionWithResponse(ctx context.Context, body ExitGemTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExitGemTransactionResponse, error) {
	rsp, err := c.ExitGemTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExitGemTransactionResponse(rsp)
}

// ResetAuctionTransactionWithBodyWithResponse request with arbitrary body returning *ResetAuctionTransactionResponse
func (c *ClientWithResponses) ResetAuctionTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetAuctionTransactionResponse, error) {
	rsp, err := c.ResetAuctionTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetAuctionTransactionResponse(rsp)
}

func (c *ClientWithResponses) ResetAuctionTransactionWithResponse(ctx context.Context, body ResetAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetAuctionTransactionResponse, error) {
	rsp, err := c.ResetAuctionTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetAuctionTransactionResponse(rsp)
}

// TakeAuctionTransactionWithBodyWithResponse request with arbitrary body returning *TakeAuctionTransactionResponse
func (c *ClientWithResponses) TakeAuctionTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TakeAuctionTransactionResponse, error) {
	rsp, err := c.TakeAuctionTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTakeAuctionTransactionResponse(rsp)
}

func (c *ClientWithResponses) TakeAuctionTransactionWithResponse(ctx context.Context, body TakeAuctionTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TakeAuctionTransactionResponse, error) {
	rsp, err := c.TakeAuctionTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTakeAuctionTransactionResponse(rsp)
}

// ExitZarTransactionWithBodyWithResponse request with arbitrary body returning *ExitZarTransactionResponse
func (c *ClientWithResponses) ExitZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExitZarTransactionResponse, error) {
	rsp, err := c.ExitZarTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExitZarTransactionResponse(rsp)
}

func (c *ClientWithResponses) ExitZarTransactionWithResponse(ctx context.Context, body ExitZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExitZarTransactionResponse, error) {
	rsp, err := c.ExitZarTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExitZarTransactionResponse(rsp)
}

// ApproveAndJoinZarTransactionWithBodyWithResponse request with arbitrary body returning *ApproveAndJoinZarTransactionResponse
func (c *ClientWithResponses) ApproveAndJoinZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ApproveAndJoinZarTransactionResponse, error) {
	rsp, err := c.ApproveAndJoinZarTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveAndJoinZarTransactionResponse(rsp)
}

func (c *ClientWithResponses) ApproveAndJoinZarTransactionWithResponse(ctx context.Context, body ApproveAndJoinZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*ApproveAndJoinZarTransactionResponse, error) {
	rsp, err := c.ApproveAndJoinZarTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseApproveAndJoinZarTransactionResponse(rsp)
}

// LiquidateVaultTransactionWithBodyWithResponse request with arbitrary body returning *LiquidateVaultTransactionResponse
func (c *ClientWithResponses) LiquidateVaultTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LiquidateVaultTransactionResponse, error) {
	rsp, err := c.LiquidateVaultTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLiquidateVaultTransactionResponse(rsp)
}

func (c *ClientWithResponses) LiquidateVaultTransactionWithResponse(ctx context.Context, body LiquidateVaultTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*LiquidateVaultTransactionResponse, error) {
	rsp, err := c.LiquidateVaultTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLiquidateVaultTransactionResponse(rsp)
}

// CreateStableCoinVaultWithBodyWithResponse request with arbitrary body returning *CreateStableCoinVaultResponse
func (c *ClientWithResponses) CreateStableCoinVaultWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStableCoinVaultResponse, error) {
	rsp, err := c.CreateStableCoinVaultWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStableCoinVaultResponse(rsp)
}

func (c *ClientWithResponses) CreateStableCoinVaultWithResponse(ctx context.Context, body CreateStableCoinVaultJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStableCoinVaultResponse, error) {
	rsp, err := c.CreateStableCoinVault(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStableCoinVaultResponse(rsp)
}

// DepositStableCoinCollateralWithBodyWithResponse request with arbitrary body returning *DepositStableCoinCollateralResponse
func (c *ClientWithResponses) DepositStableCoinCollateralWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DepositStableCoinCollateralResponse, error) {
	rsp, err := c.DepositStableCoinCollateralWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDepositStableCoinCollateralResponse(rsp)
}

func (c *ClientWithResponses) DepositStableCoinCollateralWithResponse(ctx context.Context, body DepositStableCoinCollateralJSONRequestBody, reqEditors ...RequestEditorFn) (*DepositStableCoinCollateralResponse, error) {
	rsp, err := c.DepositStableCoinCollateral(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDepositStableCoinCollateralResponse(rsp)
}

// MintZarTransactionWithBodyWithResponse request with arbitrary body returning *MintZarTransactionResponse
func (c *ClientWithResponses) MintZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MintZarTransactionResponse, error) {
	rsp, err := c.MintZarTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMintZarTransactionResponse(rsp)
}

func (c *ClientWithResponses) MintZarTransactionWithResponse(ctx context.Context, body MintZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*MintZarTransactionResponse, error) {
	rsp, err := c.MintZarTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMintZarTransactionResponse(rsp)
}

// RepayZarTransactionWithBodyWithResponse request with arbitrary body returning *RepayZarTransactionResponse
func (c *ClientWithResponses) RepayZarTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepayZarTransactionResponse, error) {
	rsp, err := c.RepayZarTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepayZarTransactionResponse(rsp)
}

func (c *ClientWithResponses) RepayZarTransactionWithResponse(ctx context.Context, body RepayZarTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*RepayZarTransactionResponse, error) {
	rsp, err := c.RepayZarTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepayZarTransactionResponse(rsp)
}

// WithdrawCollateralTransactionWithBodyWithResponse request with arbitrary body returning *WithdrawCollateralTransactionResponse
func (c *ClientWithResponses) WithdrawCollateralTransactionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WithdrawCollateralTransactionResponse, error) {
	rsp, err := c.WithdrawCollateralTransactionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWithdrawCollateralTransactionResponse(rsp)
}

func (c *ClientWithResponses) WithdrawCollateralTransactionWithResponse(ctx context.Context, body WithdrawCollateralTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*WithdrawCollateralTransactionResponse, error) {
	rsp, err := c.WithdrawCollateralTransaction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWithdrawCollateralTransactionResponse(rsp)
}

// GetStakingPlansWithResponse request returning *GetStakingPlansResponse
func (c *ClientWithResponses) GetStakingPlansWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStakingPlansResponse, error) {
	rsp, err := c.GetStakingPlans(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStakingPlansResponse(rsp)
}

// GetUserStakingStatsWithResponse request returning *GetUserStakingStatsResponse
func (c *ClientWithResponses) GetUserStakingStatsWithResponse(ctx context.Context, params *GetUserStakingStatsParams, reqEditors ...RequestEditorFn) (*GetUserStakingStatsResponse, error) {
	rsp, err := c.GetUserStakingStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserStakingStatsResponse(rsp)
}

// CollectStakingRewardWithBodyWithResponse request with arbitrary body returning *CollectStakingRewardResponse
func (c *ClientWithResponses) CollectStakingRewardWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollectStakingRewardResponse, error) {
	rsp, err := c.CollectStakingRewardWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectStakingRewardResponse(rsp)
}

func (c *ClientWithResponses) CollectStakingRewardWithResponse(ctx context.Context, body CollectStakingRewardJSONRequestBody, reqEditors ...RequestEditorFn) (*CollectStakingRewardResponse, error) {
	rsp, err := c.CollectStakingReward(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectStakingRewardResponse(rsp)
}

// StakeToStakingContractWithBodyWithResponse request with arbitrary body returning *StakeToStakingContractResponse
func (c *ClientWithResponses) StakeToStakingContractWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StakeToStakingContractResponse, error) {
	rsp, err := c.StakeToStakingContractWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStakeToStakingContractResponse(rsp)
}

func (c *ClientWithResponses) StakeToStakingContractWithResponse(ctx context.Context, body StakeToStakingContractJSONRequestBody, reqEditors ...RequestEditorFn) (*StakeToStakingContractResponse, error) {
	rsp, err := c.StakeToStakingContract(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStakeToStakingContractResponse(rsp)
}

// WithdrawStakedAssetWithBodyWithResponse request with arbitrary body returning *WithdrawStakedAssetResponse
func (c *ClientWithResponses) WithdrawStakedAssetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WithdrawStakedAssetResponse, error) {
	rsp, err := c.WithdrawStakedAssetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWithdrawStakedAssetResponse(rsp)
}

func (c *ClientWithResponses) WithdrawStakedAssetWithResponse(ctx context.Context, body WithdrawStakedAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*WithdrawStakedAssetResponse, error) {
	rsp, err := c.WithdrawStakedAsset(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWithdrawStakedAssetResponse(rsp)
}

// GetCollectorDataWithResponse request returning *GetCollectorDataResponse
func (c *ClientWithResponses) GetCollectorDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCollectorDataResponse, error) {
	rsp, err := c.GetCollectorData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectorDataResponse(rsp)
}

// GetSwapQuoteWithBodyWithResponse request with arbitrary body returning *GetSwapQuoteResponse
func (c *ClientWithResponses) GetSwapQuoteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetSwapQuoteResponse, error) {
	rsp, err := c.GetSwapQuoteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSwapQuoteResponse(rsp)
}

func (c *ClientWithResponses) GetSwapQuoteWithResponse(ctx context.Context, body GetSwapQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSwapQuoteResponse, error) {
	rsp, err := c.GetSwapQuote(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSwapQuoteResponse(rsp)
}

// GetVaultsByOwnerWithResponse request returning *GetVaultsByOwnerResponse
func (c *ClientWithResponses) GetVaultsByOwnerWithResponse(ctx context.Context, params *GetVaultsByOwnerParams, reqEditors ...RequestEditorFn) (*GetVaultsByOwnerResponse, error) {
	rsp, err := c.GetVaultsByOwner(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVaultsByOwnerResponse(rsp)
}

// GetVaultByIdWithResponse request returning *GetVaultByIdResponse
func (c *ClientWithResponses) GetVaultByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetVaultByIdResponse, error) {
	rsp, err := c.GetVaultById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVaultByIdResponse(rsp)
}

// GetVaultEventsByIdWithResponse request returning *GetVaultEventsByIdResponse
func (c *ClientWithResponses) GetVaultEventsByIdWithResponse(ctx context.Context, id int, params *GetVaultEventsByIdParams, reqEditors ...RequestEditorFn) (*GetVaultEventsByIdResponse, error) {
	rsp, err := c.GetVaultEventsById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVaultEventsByIdResponse(rsp)
}

// GetUnfilledOrdersWebsocketWithResponse request returning *GetUnfilledOrdersWebsocketResponse
func (c *ClientWithResponses) GetUnfilledOrdersWebsocketWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUnfilledOrdersWebsocketResponse, error) {
	rsp, err := c.GetUnfilledOrdersWebsocket(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUnfilledOrdersWebsocketResponse(rsp)
}

// ParseGetAccountByAddressResponse parses an HTTP response from a GetAccountByAddressWithResponse call
func ParseGetAccountByAddressResponse(rsp *http.Response) (*GetAccountByAddressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountByAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Account
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllAddressesResponse parses an HTTP response from a GetAllAddressesWithResponse call
func ParseGetAllAddressesResponse(rsp *http.Response) (*GetAllAddressesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAddressesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddressResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllIlksResponse parses an HTTP response from a GetAllIlksWithResponse call
func ParseGetAllIlksResponse(rsp *http.Response) (*GetAllIlksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllIlksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IlksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetIlkByNameResponse parses an HTTP response from a GetIlkByNameWithResponse call
func ParseGetIlkByNameResponse(rsp *http.Response) (*GetIlkByNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIlkByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ilk
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserBorrowsResponse parses an HTTP response from a GetUserBorrowsWithResponse call
func ParseGetUserBorrowsResponse(rsp *http.Response) (*GetUserBorrowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserBorrowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserBorrowsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserDepositsResponse parses an HTTP response from a GetUserDepositsWithResponse call
func ParseGetUserDepositsResponse(rsp *http.Response) (*GetUserDepositsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserDepositsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserDepositsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFetchReserveDataByAssetResponse parses an HTTP response from a FetchReserveDataByAssetWithResponse call
func ParseFetchReserveDataByAssetResponse(rsp *http.Response) (*FetchReserveDataByAssetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchReserveDataByAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FormattedReserveData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateLendingPoolBorrowResponse parses an HTTP response from a CreateLendingPoolBorrowWithResponse call
func ParseCreateLendingPoolBorrowResponse(rsp *http.Response) (*CreateLendingPoolBorrowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLendingPoolBorrowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LendingpoolBorrowTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateLendingPoolDepositResponse parses an HTTP response from a CreateLendingPoolDepositWithResponse call
func ParseCreateLendingPoolDepositResponse(rsp *http.Response) (*CreateLendingPoolDepositResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLendingPoolDepositResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LendingpoolDepositTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateLendingPoolRepayResponse parses an HTTP response from a CreateLendingPoolRepayWithResponse call
func ParseCreateLendingPoolRepayResponse(rsp *http.Response) (*CreateLendingPoolRepayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLendingPoolRepayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LendingpoolRepayTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetLendingPoolAssetCollateralResponse parses an HTTP response from a SetLendingPoolAssetCollateralWithResponse call
func ParseSetLendingPoolAssetCollateralResponse(rsp *http.Response) (*SetLendingPoolAssetCollateralResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetLendingPoolAssetCollateralResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LendingpoolUseAssetAsCollateralTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateLendingPoolWithdrawResponse parses an HTTP response from a CreateLendingPoolWithdrawWithResponse call
func ParseCreateLendingPoolWithdrawResponse(rsp *http.Response) (*CreateLendingPoolWithdrawResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLendingPoolWithdrawResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LendingpoolWithdrawTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLogsByTransactionHashResponse parses an HTTP response from a GetLogsByTransactionHashWithResponse call
func ParseGetLogsByTransactionHashResponse(rsp *http.Response) (*GetLogsByTransactionHashResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogsByTransactionHashResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventDetailsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUnfilledOrdersResponse parses an HTTP response from a GetUnfilledOrdersWithResponse call
func ParseGetUnfilledOrdersResponse(rsp *http.Response) (*GetUnfilledOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUnfilledOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrderResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSyncOrderResponse parses an HTTP response from a SyncOrderWithResponse call
func ParseSyncOrderResponse(rsp *http.Response) (*SyncOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SyncOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSingleTokenPermitResponse parses an HTTP response from a GetSingleTokenPermitWithResponse call
func ParseGetSingleTokenPermitResponse(rsp *http.Response) (*GetSingleTokenPermitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSingleTokenPermitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermitSingle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetScoreboardResponse parses an HTTP response from a GetScoreboardWithResponse call
func ParseGetScoreboardResponse(rsp *http.Response) (*GetScoreboardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScoreboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Scoreboard
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPricesResponse parses an HTTP response from a ListPricesWithResponse call
func ParseListPricesResponse(rsp *http.Response) (*ListPricesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPricesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PriceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExitGemTransactionResponse parses an HTTP response from a ExitGemTransactionWithResponse call
func ParseExitGemTransactionResponse(rsp *http.Response) (*ExitGemTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExitGemTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseResetAuctionTransactionResponse parses an HTTP response from a ResetAuctionTransactionWithResponse call
func ParseResetAuctionTransactionResponse(rsp *http.Response) (*ResetAuctionTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetAuctionTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTakeAuctionTransactionResponse parses an HTTP response from a TakeAuctionTransactionWithResponse call
func ParseTakeAuctionTransactionResponse(rsp *http.Response) (*TakeAuctionTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TakeAuctionTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExitZarTransactionResponse parses an HTTP response from a ExitZarTransactionWithResponse call
func ParseExitZarTransactionResponse(rsp *http.Response) (*ExitZarTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExitZarTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseApproveAndJoinZarTransactionResponse parses an HTTP response from a ApproveAndJoinZarTransactionWithResponse call
func ParseApproveAndJoinZarTransactionResponse(rsp *http.Response) (*ApproveAndJoinZarTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ApproveAndJoinZarTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLiquidateVaultTransactionResponse parses an HTTP response from a LiquidateVaultTransactionWithResponse call
func ParseLiquidateVaultTransactionResponse(rsp *http.Response) (*LiquidateVaultTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LiquidateVaultTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateStableCoinVaultResponse parses an HTTP response from a CreateStableCoinVaultWithResponse call
func ParseCreateStableCoinVaultResponse(rsp *http.Response) (*CreateStableCoinVaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStableCoinVaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDepositStableCoinCollateralResponse parses an HTTP response from a DepositStableCoinCollateralWithResponse call
func ParseDepositStableCoinCollateralResponse(rsp *http.Response) (*DepositStableCoinCollateralResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DepositStableCoinCollateralResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseMintZarTransactionResponse parses an HTTP response from a MintZarTransactionWithResponse call
func ParseMintZarTransactionResponse(rsp *http.Response) (*MintZarTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MintZarTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRepayZarTransactionResponse parses an HTTP response from a RepayZarTransactionWithResponse call
func ParseRepayZarTransactionResponse(rsp *http.Response) (*RepayZarTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RepayZarTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWithdrawCollateralTransactionResponse parses an HTTP response from a WithdrawCollateralTransactionWithResponse call
func ParseWithdrawCollateralTransactionResponse(rsp *http.Response) (*WithdrawCollateralTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WithdrawCollateralTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChainActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStakingPlansResponse parses an HTTP response from a GetStakingPlansWithResponse call
func ParseGetStakingPlansResponse(rsp *http.Response) (*GetStakingPlansResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStakingPlansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StakePlansResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserStakingStatsResponse parses an HTTP response from a GetUserStakingStatsWithResponse call
func ParseGetUserStakingStatsResponse(rsp *http.Response) (*GetUserStakingStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserStakingStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserStakesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCollectStakingRewardResponse parses an HTTP response from a CollectStakingRewardWithResponse call
func ParseCollectStakingRewardResponse(rsp *http.Response) (*CollectStakingRewardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectStakingRewardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StakingCollectRewardTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseStakeToStakingContractResponse parses an HTTP response from a StakeToStakingContractWithResponse call
func ParseStakeToStakingContractResponse(rsp *http.Response) (*StakeToStakingContractResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StakeToStakingContractResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StakingStakeTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseWithdrawStakedAssetResponse parses an HTTP response from a WithdrawStakedAssetWithResponse call
func ParseWithdrawStakedAssetResponse(rsp *http.Response) (*WithdrawStakedAssetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WithdrawStakedAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StakingWithdrawTxResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest UserError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCollectorDataResponse parses an HTTP response from a GetCollectorDataWithResponse call
func ParseGetCollectorDataResponse(rsp *http.Response) (*GetCollectorDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectorDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Stats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSwapQuoteResponse parses an HTTP response from a GetSwapQuoteWithResponse call
func ParseGetSwapQuoteResponse(rsp *http.Response) (*GetSwapQuoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSwapQuoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuoteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVaultsByOwnerResponse parses an HTTP response from a GetVaultsByOwnerWithResponse call
func ParseGetVaultsByOwnerResponse(rsp *http.Response) (*GetVaultsByOwnerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVaultsByOwnerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VaultsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVaultByIdResponse parses an HTTP response from a GetVaultByIdWithResponse call
func ParseGetVaultByIdResponse(rsp *http.Response) (*GetVaultByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVaultByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Vault
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVaultEventsByIdResponse parses an HTTP response from a GetVaultEventsByIdWithResponse call
func ParseGetVaultEventsByIdResponse(rsp *http.Response) (*GetVaultEventsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVaultEventsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VaultEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUnfilledOrdersWebsocketResponse parses an HTTP response from a GetUnfilledOrdersWebsocketWithResponse call
func ParseGetUnfilledOrdersWebsocketResponse(rsp *http.Response) (*GetUnfilledOrdersWebsocketResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUnfilledOrdersWebsocketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
